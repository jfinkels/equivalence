%% intermediary.tex - NP-intermediary equivalence relations
%%
%% Copyright 2010, 2011, 2012, 2014, 2015 Jeffrey Finkelstein.
%%
%% This LaTeX markup document is made available under the terms of the Creative
%% Commons Attribution-ShareAlike 4.0 International License,
%% https://creativecommons.org/licenses/by-sa/4.0/.
\section{Existence of intermediary problems}
\label{sec:intermediary}
% Foreword
%
% context (focus on anyone) why now? - current situation, and why the need is so important
According to the seminal theorem by Ladner \autocite{ladner75}, if $\P \neq \NP$, then there are problems of intermediate complexity, in the sense that these problems are neither in $\P$ nor $\NP$-complete.
The theorem does not immediately imply a similar result for equivalence problems, since $\PEq$ is different from $\P$ and $\NPEq$ is different from $\NP$ (specifically, in each case, the latter contains problems that are not equivalence problems).
% need (focus on readers) why you? - why this is relevant to the reader, and why something needed to be done
Do kernel reductions induce the same rich structure between $\PEq$ and $\NPEq$ as do many-one reductions between $\P$ and $\NP$?
% task (focus on author) why me? - what was undertaken to address the need
We adapt a proof of Ladner's theorem from \autocite{df03} (which has been attributed to Russell~Impagliazzo) to classes of equivalence problems;
%% We adapt Schöning's Uniform Diagonalization Theorem \autocite{schoning82}, a generalized version of Ladner's Theorem, to classes of equivalence problems.
%% The specific presentation we follow is from \autocite{bdg95}.
% object (focus on document) why this document - what the document covers
this section details that adaptation.

% Summary
%
% findings (focus on author) what? - what the work revealed when performing the task
The main theorem of this section is the existence of $\NPEq$-intermediary problems under the assumption that $\PEq \neq \NPEq$ (which is equivalent to the assumption $\P \neq \NP$ by \autoref{thm:pnppeqnpeq}).
%% Although this theorem relies on the assumption that there is an $\NPEq$-complete problems, no such assumption is required to show the existence of intermediary problems between, say, $\PHEq$ and $\PSPACEEq$ (\autoref{cor:pspace}).
% conclusion (focus on readers) so what? - what the findings mean for the audience
We conclude that even though kernel reductions are strictly weaker than many-one reductions, they still preserve the hierarchies of problems of various computational complexities we expect from our understanding of traditional complexity classes.
% perspective (focus on anyone) what now? - what should be done next
The graph isomorphism problem, as one of the few candidates for an $\NP$-intermediary problem, may be the best candidate for an $\NPEq$-intermediary problem as well.

\begin{theorem}\label{thm:intermediary}
  If $\PEq \neq \NPEq$, then there is an equivalence relation in $\NPEq$ that is neither in $\PEq$ nor $\NPEq$-complete.
\end{theorem}
\begin{proof}
  Let $K$ be an $\NP$-complete equivalence relation.
  We know that such equivalence relations exist by \autoref{thm:npceqrel}.
  Define the equivalence relation $R$ by
  \begin{equation*}
    R = \left\{\left\langle x 0 1^{f(n) - n - 1}, y 0 1^{f(n) - n - 1}\right\rangle \, \middle| \, \pair{x}{y} \in K \text{ and } |x| = |y| = n\right\},
  \end{equation*}
  where $f$ is a function that will be defined below.
  The problem $R$ is a padded version of the problem $K$.

  Our goal is to define the function $f$ so that $R$ is not too hard and not too easy: it's output should be large enough that $R$ is not $\NPEq$-complete but not so large that $R$ is in $\P$.
  For this we need an enumeration of each polynomially clocked Turing machine, $\{M_i\}_i$.
  We define $f$ for each positive integer $n$ by the following iterative process (and thus we implicitly define $R$ iteratively as well).
  Initially, let $i = 1$, then perform the following steps for each $n$ in order.
  \begin{itemize}
  \item Define $f(n)$ to be $n^i$.
  \item
    Check if there is any pair of strings $x$ and $y$ of length at most $\log n$ such that
    \begin{itemize}
    \item $M_i(\pair{x}{y})$ accepts and $\pair{x}{y} \notin R$, or
    \item $M_i(\pair{x}{y})$ rejects and $\pair{x}{y} \in R$.
    \end{itemize}
    If any such pair exists, increment $i$.
  \end{itemize}

  The function $f$ is computable in time polynomial in $n$.
  Computing $f(n)$ requires computing $f(1)$, $f(2)$, $\dotsc$, $f(n - 1)$; if each of these $n - 1$ computations takes a polynomial amount of time, the total time required to compute $f(n)$ remains polynomial in $n$, by induction.
  Since the strings $x$ and $y$ are of length at most $\log n$, the total number of iterations required to test all pairs of strings is polynomial in $n$.
  \todo{Why is $M_i(\pair{x}{y})$ computable in time polynomial in $n$? It seems like it should be computable in time $O(i (\log n)^i)$, but $i$ could be as large as $n$.}
  The language $R$ is in $\NPEq$ because it is a padded version of the language $K$, which is in $\NPEq$.
  Since $\NP \subseteq \EXP$ and the inputs $x$ and $y$ are each of length $\log n$, membership in $R$ can be determined in time polynomial in $n$.
  (Even though the definition of $R$ requires $f$ to be defined, $f$ is already defined for strings of length less than $n$, including the strings $x$ and $y$.)
  Since each step can be performed in polynomial time and there are at most $n$ iterations required when defining $f(n)$, we conclude that $f$ is computable in time polynomial in $n$.

  Now we must show that $R \notin \PEq$ and $R$ is not $\NPEq$-complete.
  First, assume with the intention of producing a contradiction that $R \in \PEq$.
  Thus there is a natural number $i$ such that $M_i$ decides $R$.
  For sufficiently large $n$, the machine $M_i$ never disagrees with $R$, so $f(n) = n^i$ for all sufficiently large $n$.
  This yields a polynomial-time kernel reduction from $K$ to $R$ via the function $\pair{x}{y} \mapsto \left\langle x 0 1^{f(n) - n - 1}, y 0 1^{f(n) - n - 1}\right\rangle$, where $|x| = |y| = n$.
  This mapping is polynomial-time computable because $f(n) = n^i$ for all sufficiently large $n$, and $i$ does not depend on $n$.
  Since $\PEq$ is closed under polynomial-time kernel reductions, $K$ is in $\PEq$, and hence $\PEq = \NPEq$, since $K$ is $\NPEq$-complete.
  This is a contradiction with the assumption that $\PEq \neq \NPEq$, hence $R \notin \PEq$.

  Second, assume with the intention of producing a contradiction that $R$ is $\NPEq$-complete.
  Thus $K \kr R$, so there is a function $f_j$ such that $f_j$ halts within $n^j$ steps and for each string $x$ and $y$, we have $\pair{x}{y} \in K$ if and only if $\pair{f_j(x)}{f_j(y)} \in R$.
  \todo{I don't quite see how to get this next sentence; it seems to come from the fact that the image of $K$ under $f_j$ is infinite (if it were finite, the problem would be in $\P$).}
  There is a $k$ greater than $j$ and an $n_0$ such that for each $n \geq n_0$, we have $f(n) = n^k$.
  Now we can construct a polynomial-time algorithm for $K$.
  Assume without loss of generality that all inputs are pairs of strings of equal length.
  On inputs of the form $\pair{x}{y}$, proceed as follows.
  \begin{itemize}
  \item If $|x| < n_0$ (or equivalently $|y| < n_0$), decide whether $\pair{x}{y} \in K$ by examining a hardcoded lookup table for strings of length less than $n_0$.
  \item Compute $f_j(x)$ and $f_j(y)$.
  \item If either $|f_j(x)|$ or $|f_j(y)|$ is not in the range of $f$, reject.
  \item
    Suppose $f_j(x) = x' 0 1^{f(m) - m - 1}$ and $f_j(y) = y' 0 1^{f(\ell) - \ell - 1}$, where $|x'| = m$ and $|y'| = \ell$.
    Invoke this algorithm recursively on input $\pair{x'}{y'}$.
  \end{itemize}

  Assuming for now that $x'$ and $y'$ are shorter than $x$ and $y$.
  Then the correctness of this algorithm follows from the fact that
  \begin{equation*}
    \pair{x}{y} \in K \iff \pair{f_j(x)}{f_j(y)} \in R \iff \pair{x'}{y'} \in K.
  \end{equation*}
  Since the length of the inputs to the algorithm decrease on each recursive invocation, there are at most $n$ recursive calls on inputs of pairs of strings of length $n$.
  Eventually the solution can be found in the hardcoded lookup table (the base case of the recursion).
  Each recursive invocation of the algorithm other than the base case requires computing $f_j$ on an input of length $n$ (twice), which can be done in polynomial time.
  Thus the overall time required for this algorithm is polynomial in $n$.
  This proves that $K \in \P$ and thus $\P = \NP$.
  Since $\P = \NP$ if and only if $\PEq = \NPEq$, we have a contradiction.

  Finally, we prove that $|x'| < |x|$ (the proof that $|y'| < |y|$ is the same), which we postponed from the previous paragraph.
  Due to its time bound, $|f_j(x)| \leq |x|^j$ for any string $x$.
  By assumption, $f(|x'|) = |x'|^k$.
  By construction, $f(|x'|) = |f_j(x)|$
  Combining these three relations yields the inequality
  \begin{equation*}
    |x'|^k = f(|x'|) = |f_j(x)| \leq |x|^j,
  \end{equation*}
  so $|x'| \leq |x|^{j / k} < |x|$, since $k > j$ and lengths must be natural numbers.
\end{proof}

\todo{Explain why uniform diagonalization doesn't work; well, the uniform diagonalization theorem I think still holds, but we just can't enumerate NPEq, for example, because that is equivalent to showing a complete problem.}

\todo{Recheck and rephrase this.}
This also introduces a host of similar corollaries showing the existence of intermediary problems for other classes of equivalence relations which have $\kr$-complete problems; for more examples, see the original paper by Schöning \autocite{schoning82}.
In particular, we can make the following stronger statement using \autoref{cor:hardproblems}.
(Note that $\PHEq$ is the class of equivalence relations in $\PH$, the polynomial hierarchy.)
\begin{corollary}\label{cor:pspace}
  If $\PSPACEEq \neq \PHEq$ then there is an equivalence relation in $\PSPACEEq$ which is neither in $\PHEq$ nor $\PSPACEEq$-complete.
\end{corollary}

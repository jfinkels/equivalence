%% generalcompleteness.tex - completeness under kernel reductions
%%
%% Copyright 2010, 2011, 2012, 2014 Jeffrey Finkelstein.
%%
%% This LaTeX markup document is made available under the terms of the Creative
%% Commons Attribution-ShareAlike 4.0 International License,
%% https://creativecommons.org/licenses/by-sa/4.0/.
\section{Conditions for complete problems under polynomial time kernel reductions}
\label{sec:generalcompleteness}

In this section we use the techniques of \autocite[Theorem~8.7]{bcffm} to present a general theorem which provides equivalence relations which are hard for a number of interesting complexity classes under polynomial time kernel reductions.
We need one additional definition here.
If $\mathcal{C}$ is a complexity class then the class $\forall\mathcal{C}$ is the set of languages $A$ such that there exists a language $B\in\mathcal{C}$ and a polynomial $p$ satisfying $x\in A$ if and only if $\forall w\in\Sigma^{\leq p(|x|)} \pair{x}{w}\in B$.
$\forall\mathcal{C}$ is called the \defn{closure of $\mathcal{C}$ under polynomially bounded universal quantification}.

\begin{theorem}\label{thm:generalcompleteness}
  Let $\mathcal{C}$ be a subset of $\PSPACE$ which contains the problem of deciding whether two strings are equal.
  Then there exists an equivalence relation in $\CRAZYEq$ which is hard for $\CEq$ under $\kr$ reductions.
\end{theorem}

Before proving this theorem, we will provide some immediate corollaries of this general result.

\begin{corollary}
  If $\mathcal{C}$ is a subset of $\PSPACE$ and $\mathcal{C}=\CRAZY$, then $\CEq$ has a complete problem under $\kr$ reductions.
\end{corollary}

\begin{corollary}\label{cor:hardproblems}
  Under polynomial time kernel reductions,
  \begin{enumerate}
  %\item $\EXPEq$ has a complete problem
  \item $\PSPACEEq$ has a complete problem
  \item $\PKPEq$ contains a problem that is hard for $\DKPEq$, for all $k \geq 1$
  %\item\label{itm:hardforsigma} $\PKPOPEq$ contains a problem which is hard for $\SKPEq$, for all $k\geq 0$
  %\item $\PKPOPEq$ contains a problem which is hard for $\PKPEq$, for all $k\geq 0$
  %\item $\coNPEq$ contains a problem which is hard for $\PEq$
  \end{enumerate}
\end{corollary}
\begin{proof}\mbox{}
  \begin{enumerate}
  %\item $\EXP$ is closed under complement (because it is a deterministic complexity class) and polynomially bounded universal quantification (because we can simulate the universal guess deterministically in exponential time).
  \item $\PSPACE$ is closed under complement (because it is a deterministic complexity class) and polynomially bounded universal quantification (because we can simulate the universal guess deterministically in polynomial space).
  \item
    First, $(\forall(\DKP \cup \mathsf{co}\DKP))\mathsf{Eq} = (\forall \DKP)\mathsf{Eq}$, since $\DKP$ is closed under complement.  % \autocite[Proposition~8.4 (a)]{bdg95}
    Next, $(\forall \DKP)\mathsf{Eq} = \PKPEq$, since $\forall \DKP = \PKP$.  % \autocite[Proposition~8.3 (g)]{bdg95}
    Now if $\mathcal{C} = \DKP$, then $\PKP$ has a problem that is hard for $\DKP$ under $\kr$ reductions.
    \qedhere
  %\item If $\mathcal{C}=\SKP$, then the $\kr$-hard problem is in $(\forall(\SKP\cup\mathsf{co}\SKP))\mathsf{Eq}=(\forall(\SKP\cup\PKP))\mathsf{Eq}=\PKPOPEq$.
  %\item Same as the previous justification, but starting with $\mathcal{C}=\PKP$.\qedhere
%  \item Same as the previous justification, but starting with $\mathcal{C}=\P$.
  \end{enumerate}
\end{proof}

More specifically, this means that $\coNPEq$ (which equals $\POPEq$) has a problem which is $\kr$-hard for $\PEq$ (which equals $\DOPEq$).
This leads to \autocite[Theorem~8.7, part~1]{bcffm}, which is restated here.

\begin{corollary}[{\autocite[Theorem~8.7, part~1]{bcffm}}]
  If $\NP = \coNP$ then $\NPEq$ has a complete problem under polynomial time kernel reductions.
\end{corollary}
\begin{proof}
  If $\NP = \coNP$, then the polynomial hierarchy collapses to $\POP$, and specifically $\PTP = \DOP = \POP = \coNP = \NP$.
  From \autoref{cor:hardproblems} we conclude that $\NPEq$ has a $\kr$-hard problem for $\NPEq$.
  Such a problem is by definition $\NPEq$-complete.
\end{proof}

We now return to the proof of \autoref{thm:generalcompleteness} by first providing some motivating ideas.
Recall the canonical complete problem (sometimes called the ``universal'' problem) for $\NP$ (and indeed for various other complexity classes):
\begin{displaymath}
  K = \lb\triple{M}{x}{1^t} \st M\plain{accepts} x \plain{within} t \textnormal{ steps}\rb
\end{displaymath}
The idea of this proof is to adapt this into an equivalence relation $R_K$ consisting of pairs of triples of the form $\pair{\triple{M}{x}{1^{t_x}}}{\triple{M}{y}{1^{t_y}}}$, where $M$ accepts $\pair{x}{y}$, as in the reduction from an arbitrary $\NP$ language to $K$.
The problem we encounter here is that $R_K$ is not necessarily an equivalence relation.
Consider, for example, transitivity, which must be satisfied for all possible pairs of the form $\triple{M}{w}{1^{t_w}}$.
For \emph{arbitrary machines} $M$, just because $M$ accepts $\pair{x}{y}$ and $\pair{y}{z}$ does not necessarily mean that $M$ accepts $\pair{x}{z}$.
The solution is to encode into $R_K$ the requirement that the language which $M$ accepts, $L(M)$, is itself an equivalence relation.
The three properties required of $R_K$ then follow from the properties of $L(M)$.
%
%As a technical consideration for this proof, we point out languages in $\PSPACE$ may be decided by alternating Turing machines which run in polynomial time, so it is permissible to consider polynomially clocked Turing machines.
%
\begin{proof}[Proof of \autoref{thm:generalcompleteness}]
  First we will define a helper algorithm which decides whether a given machine accepts an equivalence relation on strings up to a given length.
  Define the algorithm $A$ as follows on input $\pair{M}{n}$, where $M$ is a polynomially clocked Turing machine of type $\mathcal{C}$ and $n\in\mathbb{N}$:
  \begin{enumerate}
  \item universally guess $a,b,$ and $c\in\Sigma^{\leq n}$
  \item simulate $M$ on $\pair{a}{a}$; if it rejects, reject
  \item simulate $M$ on $\pair{a}{b}$, then on $\pair{b}{a}$; if the former accepts and the latter rejects, reject
  \item simulate $M$ on $\pair{a}{b}$, then on $\pair{b}{c}$, then on $\pair{a}{c}$; if the first two accept and the last one rejects, reject
  \item if execution reaches this point, accept
  \end{enumerate}
  These simulations check that $L(M)$ satisfies reflexivity, symmetry, and transitivity on strings of length at most $n$.
  If $A$ accepts, then the three properties are satisfied, and if it rejects then one of the three properties is violated.
  Since $M$ is a machine of type $\mathcal{C}$, checking if $M$ accepts on some input and if $M$ rejects on some input is in $\mathcal{C}\cup\mathsf{co}\mathcal{C}$.
  The universal guesses of $a,b,$ and $c$ (of length at most $n$) followed by checks of whether the six simulations of $M$ accept or reject place $L(A)$ in the class $\CRAZY$.
  If $p$ is the polynomial which bounds the running time of $M$, then the running time of this algorithm is $6p\left(\left|\pair{1^n}{1^n}\right|\right)+c$, where $c$ is a constant which represents the time needed to account for the implementation of $A$ (the control of the simulations of $M$, performing logical conjunctions, etc.).
  Hence the running time of $A$ is polynomial in $n$.

  Now we can define the set $R_K$ by
  \begin{align*}
    R_K = {} & \lb\pair{u}{v} \st u=v\rb \\
    & \cup \lb\pair{\triple{M}{x}{1^{t_x}}}{\triple{M}{y}{1^{t_y}}} \st \textnormal{1 through 4 below are satisfied}\rb
  \end{align*}
  where the conditions are
  \begin{enumerate}
  \item\label{itm:machine} $M$ is a polynomially clocked Turing machine of type $\mathcal{C}$
  \item\label{itm:emx} $A$ accepts $\pair{M}{|x|}$ within $t_x$ steps
  \item\label{itm:emy} $A$ accepts $\pair{M}{|y|}$ within $t_y$ steps
  \item\label{itm:accepts} $M$ accepts $\pair{x}{y}$
  \end{enumerate}
  We claim that $R_K$ is in $\CRAZYEq$ and $\CEq$-hard.

  First we show that $R_K\in\CRAZY$.
  By the argument above, $A$ is a $\CRAZY$ algorithm.
  %Since $M$ is a polynomially clocked $\mathcal{C}$ machine by \autoref{itm:machine}, then the simulation of $M$ on $\pair{x}{y}$ in \autoref{itm:accepts} can be performed by a $\mathcal{C}$ algorithm.
  Assuming without loss of generality that $|x|\geq |y|$, if $A$ accepts $\pair{M}{|x|}$ within $t_x$ steps then we know that there is a polynomial time bound on the running time of $M$ on input $\pair{x}{y}$, so simulating it is certainly in $\CRAZY$.
  Finally, testing for equality is in $\mathcal{C}$ by hypothesis so deciding $R_K$ overall can be performed by a $\CRAZY$ algorithm.

  Next we show that $R_K$ is an equivalence relation.
  Reflexivity follows from the reflexivity of the equality relation.
  For symmetry, suppose $\pair{\triple{M}{x}{1^{t_x}}}{\triple{M}{y}{1^{t_y}}}\in R_K$.
  Since \autoref{itm:emx} and \autoref{itm:emy} are true by hypothesis, we know that symmetry on strings of length at most $\max(|x|, |y|)$ in $L(M)$ is satisfied, and that includes the strings $x$ and $y$.
  So since $M$ accepts $\pair{x}{y}$ it must follow that $M$ accepts $\pair{y}{x}$.
  Furthermore, \autoref{itm:machine}, \autoref{itm:emx}, and \autoref{itm:emy} are the same up to symmetry of $x$ and $y$, so we have $\pair{\triple{M}{y}{1^{t_y}}}{\triple{M}{x}{1^{t_x}}}\in R_K$.
  For transitivity, suppose that both $\pair{\triple{M}{x}{1^{t_x}}}{\triple{M}{y}{1^{t_y}}}\in R_K$ and $\pair{\triple{M}{y}{1^{t_y}}}{\triple{M}{z}{1^{t_z}}}\in R_K$.
  Since transitivity is true on strings of length at most $\max(|x|, |y|, |z|)$ by the transitivity propositions checked by \autoref{itm:emx} and \autoref{itm:emy}, and since $M$ accepts both $\pair{x}{y}$ and $\pair{y}{z}$ by hypothesis, it must follow that $M$ accepts $\pair{x}{z}$.
  Again the conditions in \autoref{itm:machine}, \autoref{itm:emx}, and \autoref{itm:emy} are the same.
  We have shown that $R_K$ is reflexive, symmetric, and transitive, so it is an equivalence relation.
  At this point, we have proven that $R_K\in\CRAZYEq$.

  Now we need to show that $R_K$ is $\CEq$-hard.
  Let $S\in\CEq$.
  Suppose $M$ is the polynomially clocked $\mathcal{C}$ machine which decides $S$, and $p$ is the polynomial which bounds the running time of $M$.
  Then the kernel reduction from $S$ to $R_K$ is $w\mapsto\triple{M}{w}{1^{6p(|\pair{w}{w}|)+c}}$, where $p$ and $c$ are the polynomial and constant described in the first paragraph of this proof.
  Call this reduction $f$.
  The reduction is obviously computable in time polynomial in $|w|$.
  It remains to show that this reduction is correct.

  Suppose $\pair{x}{y}\in S$.
  Now $f(x)=\triple{M}{x}{1^{6p(|\pair{x}{x}|)+c}}$ and $f(y)=\triple{M}{y}{1^{6p(|\pair{y}{y}|)+c}}$.
  \autoref{itm:machine} is true by construction, and \autoref{itm:accepts} is true since $M$ is the machine which decides $S$.
  Assume \autoref{itm:emx} is false.
  Then $M$ does not accept an equivalence relation on strings of length at most $|x|$.
  This is a contradiction, since $M$ decides $S$, an equivalence relation, by hypothesis.
  Therefore \autoref{itm:emx} must be satisfied.
  The same argument applies to \autoref{itm:emy}.
  Hence $\pair{f(x)}{f(y)}\in R_K$.

  If $\pair{x}{y}\notin S$ then $M$ does not accept $\pair{x}{y}$, since otherwise $\pair{x}{y}$ would be a member of $S$.
  Hence $\pair{x}{y}\notin R_K$.
  Therefore we have shown that $R_K$ is $\CEq$-hard.
\end{proof}

\begin{openproblem}
  Is there a more general characterization of complexity classes which have a $\kr$-hard problem?
\end{openproblem}

\begin{openproblem}
  Under what conditions does a complexity class have a complete problem?
  Can we adapt this idea to create a complete problem for $\PEq$ or $\NPEq$?
\end{openproblem}

\begin{openproblem}
  Can this theorem be used to construct $\krnt$-hard problems for smaller complexity classes like $\NLEq$ under the appropriate time-bounded reduction?
  Larger classes such as $\EXPEq$?
\end{openproblem}

\begin{openproblem}
  To what other equivalence relations does our $\kr$-hard problem reduce?
  Are there ``natural'' $\kr$-hard problems in complexity classes which satisfy the conditions in \autoref{thm:generalcompleteness}?
\end{openproblem}

As an additional corollary, we show that the equivalence relation $R_K$ is necessarily hard given a known hard equivalence relation under $\kr$ reductions.

\begin{corollary}
  Let $\mathcal{C}_1$ be a complexity class and $\mathcal{C}_2$ be a subset of $\PSPACE$ which contains the problem of deciding whether two strings are equal.
  If there exists an equivalence relation $S$ in $\CTEq$ which is hard for $\COEq$ under $\kr$ reductions, then there is an equivalence relation in $\CRAZIEREq$ which is hard for $\COEq$ under $\kr$ reductions.
\end{corollary}
\begin{proof}
  $S\kr R_K$ by the reduction described in the proof of \autoref{thm:generalcompleteness}.
  A similar analysis shows that $R_K\in\CRAZIEREq$.
  Since $S$ is hard for $\COEq$ and polynomial time kernel reductions compose by \autoref{prop:compose}, $R_K$ is also hard for $\COEq$.
\end{proof}

Finally, the following theorem is inspired by Mahaney's theorem, which states that there are no sparse \NP-complete languages unless $\P=\NP$.
Our result concerns not the sparseness of strings in a language, but the sparseness of equivalence classes in an equivalence relation.
This complements the work on ``potential reducibility'', defined in section 5 of \autocite{bcffm}.

\begin{definition}[{\autocite[Definition~7.2]{bcffm}}]
  \mbox{}
  \begin{enumerate}
  \item If $R$ is an equivalence relation on $\Sigma^*$, then define $\#R(n)$ to be $\left|\{[x]_R | x \in \Sigma^{\leq n}\}\right|$, or in other words, $\#R(n)$ is the number of equivalence classes in $R$ for strings of length at most $n$.
  \item
    Let $R$ and $S$ be equivalence relations on $\Sigma^*$.
    $R$ is \defn{potentially reducible} to $S$, denoted $R\pot S$, if there exists a polynomial $p$ such that for all $n\in\mathbb{N}$, $\#R(n)\leq \#S(p(n))$.
  \end{enumerate}
\end{definition}

It follows from the definitions that for any equivalence relations $R$ and $S$, $R\kr S\implies R\pot S$, and hence $R\npot S \implies R\nkr S$ (this is stated and proven explicitly in \autocite[Lemma~5.5]{bcffm}).
As an analog to traditional sparse languages, we provide a definition of ``kernel sparsity'', and show its application to determining potential reducibility and hence kernel reducibility.

\begin{definition}
  An equivalence relation $R$ on $\Sigma^*$ is \defn{kernel sparse} if there exists a polynomial $p$ such that for all $n\in\mathbb{N}$, $\#R(n)\leq p(n)$.
  In other words, the number of equivalence classes in $R$ for strings of length at most $n$ is bounded above by a polynomial in $n$.

  An equivalence relation is \defn{kernel dense} if it is not kernel sparse.
  Formally, if for all polynomials $p$ there exists an $n\in\mathbb{N}$ such that $\#R(n)>p(n)$.
  In other words, the number of equivalence classes in $R$ for strings of length at most $n$ is greater than any polynomial in $n$.
\end{definition}

These definitions allow us to provide the following very natural proposition.
Intuitively, it states that an equivalence relation with many closely packed equivalence classes cannot reduce (under polynomially bounded notions of reduction) to an equivalence relation with few but widely spaced equivalence classes.

\begin{theorem}\label{thm:density}
  Let $R$ and $S$ be equivalence relations on $\Sigma^*$.
  If $R$ is kernel dense and $S$ is kernel sparse, then $R\npot S$ and in particular $R\nkr S$.
\end{theorem}
\begin{proof}
  That $R\npot S$ implies $R\nkr S$ was already stated in the text following the definition of potential reducibility, so it suffices to show that $R\npot S$.

  Assume that $R\pot S$ with the intention of producing a contradiction.
  Let $p$ be the polynomial such that $\#R(n)\leq \#S(p(n))$ (this is the definition of potential reducibility).
  Let $q$ be the polynomial such that for all $n$, $\#S(n)< q(n)$ (this is the definition of kernel sparse).
  %% TODO is this true?
  Assume without loss of generality that $q$ is non-decreasing (we can do this because for each polynomial $a$ there exists a non-decreasing polynomial $b$ such that $a(n)\leq b(n)$ for all $n$).
  For each natural number $n$, we have $\#S(n) \leq q(0) + q(1) + \cdots + q(n) \leq n \cdot q(n)$ (since $q$ is non-decreasing).
  Replacing $n$ with $p(n)$ in the above inequality, it follows that $\#S(p(n)) \leq p(n) \cdot q(p(n))$, which is a polynomial in $n$.
  (This is an overestimate, but we can be generous here and still produce a contradiction.)
  Let $r(n)=p(n)\cdot q(p(n))$.

  Let $n_0$ be the natural number such that $\#R(n_0) > r(n_0)$, by the definition of kernel sparse.
  Since $\#S(p(n_0)) \leq r(n_0)$, we have $\#R(n_0) > \#S(p(n_0))$.
  In other words, there are more equivalence classes in $R$ for strings up to length $n_0$ than there are in $S$ for strings up to length $p(n_0)$.
  By the pigeonhole principle, we conclude that $R$ cannot potentially reduce to $S$, because the number of equivalence classes in $R$ for strings up to length $n_0$ is too great compared to the number of equivalence classes in $S$ for strings up to length $p(n_0)$.
  This is a contradiction with the assumption that $R\pot S$.
  We have shown this for arbitrary polynomials (which came from the definitions of potential reducibility and kernel sparsity), so we can conclude that the result holds for all equivalence relations $R$ and $S$ which are kernel dense and kernel sparse, respectively.
\end{proof}

This places a strong restriction on equivalence relations which are hard (or complete) under polynomial time kernel reductions: they cannot be kernel sparse.

\begin{corollary}
  Let $\CEq$ be a complexity class of equivalence relations containing the equality relation, $R_{eq}=\lb\pair{x}{y} \st x=y\rb$.
  If an equivalence relation $R$ is $\CEq$-hard then it is not kernel sparse (that is, it is kernel dense).
\end{corollary}
\begin{proof}
  $R_{eq}$ is kernel dense since it contains $2^n$ equivalence classes at each length $n$---one for each distinct string.
  If $R$ were kernel sparse then $R_{eq}\npot R$ by \autoref{thm:density}.
  This would imply $R_{eq}\nkr R$, which is a contradiction with the hypothesis that all equivalence relations in $\CEq$ (including $R_{eq}$) polynomial time kernel reduce to $R$.
  Therefore $R$ is not kernel sparse.
\end{proof}

%% This last question leads us to briefly note that equivalence of true quantified boolean formulas is a \PSPACE-complete problem; perhaps it is also a \PSPACEEq-complete problem.
%% \begin{proposition}
%%   Define $\QBFEq$ by
%%   \begin{displaymath}
%%     \QBFEq = \{\pair{\phi}{\psi} | \phi \iff \psi\},
%%   \end{displaymath}
%%   where $\phi$ and $\psi$ are fully quantified boolean formulae.
%%   Then $\QBFEq$ is \PSPACE-complete.
%% \end{proposition}
%% \begin{proof}
%%   Suppose $\phi$ denotes $\overline{Q}\tau$, where $\overline{Q}$ represents the sequence of quantified variables and $\tau$ is the boolean formula over those variables.
%%   Then the many-one reduction from $\QBF$ is $\phi\mapsto\pair{\phi}{\exists z\colon\overline{Q}(\tau\land z)}$, where $z$ is a variable not already in $\phi$.
%%   This reduction can obviously be computed in time polynomial in the length of the input, $\phi$.
%%   If $\phi$ is not satisfiable, then no assignment of $z$ makes $\overline{Q}(\tau\land z)$ satisfiable, because $\tau$ will always be false.
%%   Hence $\exists z\colon\overline{Q}(\tau\land z)$ must be false.
%%   If $\phi$ is satisfiable, then choosing $z$ to be true makes $\overline{Q}(\tau\land z)$ true.
%%   Thus $\phi$ is satisfiable if and only if $\exists z\colon\overline{Q}(\tau\land z)$ is satisfiable, so $\QBF\mor\QBFEq$.
%%   Since $\QBFEq$ is clearly decidable in $\PSPACE$, we conclude that $\QBFEq$ is \PSPACE-complete.
%% \end{proof}

The idea behind \autoref{thm:density} leads to a proof that polynomial time many-one reductions are more powerful than polynomial time \emph{length-preserving} kernel reductions, where a function $f$ is length-preserving if $|f(x)| \geq |x|$.

\begin{theorem}
  There are equivalence relations $R$ and $S$ such that $R \mor S$ but there is no polynomial time length-preserving kernel reduction from $R$ to $S$.
  Furthermore, $R$ and $S$ are in complexity class ???.
\end{theorem}
\begin{proof}
  Let $f_0, f_1, \dotsc$ be an enumeration of all polynomial time computable functions.
  Assume without loss of generality (TODO state why???) that for all natural numbers $i$, function $f_i$ runs in time $p_i(n)$, where $p_i(n) = i n^i$ for all natural numbers $n$.
  We will define the equivalence relations $R$ and $S$ by their equivalence classes, and we will define the equivalence classes inductively.
  For each positive integer $i$, let $n_i = 2^{n_{i - 1}} + 1$ and let $n_0 = 0$.
  Let the $i$th equivalence class of $R$ be the set of all strings $s$ satisfying the inequality $n_i \leq |s| < n_{i + 1}$.
  The first equivalence class in $S$ is the set of all strings of length at most $p(n_1)$
  %Let the $i$th equivalence class of $S$ be the set of all strings $t$ satisfying the inequality $p_i(n_i) \leq |t| < p_i(n_{i + 1})$ (technically, the $0$th equivalence class must be the set of all $t$ such that $0 \leq |t| < p(n_1)$).
  %\textbf{TODO: There's a range of lengths that are not covered in $S$: from the end of $p_i(n_{i + 1})$ to the beginning of $p_{i + 1}(n_{i + 1})$.}

  There is a many-one reduction from $R$ to $S$.
  The reduction $m$ operates as follows.
  %On input $\pair{x}{y}$, first decide if $x$ and $y$ are in the same equivalence class in $R$.
  %If they are not, output $\pair{x_{\text{small}}}{y_{\text{large}}}$, where $x_{\text{small}}$ is a string of length less than $n_i$,
\end{proof}

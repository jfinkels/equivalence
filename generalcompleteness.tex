%%%%
%% generalcompleteness.tex
%%
%% Copyright 2011, 2012 Jeffrey Finkelstein
%%
%% Except where otherwise noted, this work is made available under the terms of
%% the Creative Commons Attribution-ShareAlike 3.0 license,
%% http://creativecommons.org/licenses/by-sa/3.0/.
%%
%% You are free:
%%    * to Share — to copy, distribute and transmit the work
%%    * to Remix — to adapt the work
%% Under the following conditions:
%%    * Attribution — You must attribute the work in the manner specified by
%%    the author or licensor (but not in any way that suggests that they
%%    endorse you or your use of the work).
%%    * Share Alike — If you alter, transform, or build upon this work, you may
%%    distribute the resulting work only under the same, similar or a 
%%    compatible license.
%%    * For any reuse or distribution, you must make clear to others the 
%%    license terms of this work. The best way to do this is with a link to the
%%    web page http://creativecommons.org/licenses/by-sa/3.0/.
%%    * Any of the above conditions can be waived if you get permission from
%%    the copyright holder.
%%    * Nothing in this license impairs or restricts the author's moral rights.
%%%%
\section{Conditions for complete problems under polynomial time kernel reductions}
\label{sec:generalcompleteness}

In this section we use the techniques of \cite[Theorem~8.7]{bcffm} to present a general theorem which provides equivalence relations which are hard for a number of interesting complexity classes under polynomial time kernel reductions.
We need one additional definition here.
If $\mathcal{C}$ is a complexity class then the class $\forall\mathcal{C}$ is the set of languages $A$ such that there exists a language $B\in\mathcal{C}$ and a polynomial $p$ satisfying $x\in A$ if and only if $\forall w\in\Sigma^{\leq p(|x|)} \pair{x}{w}\in B$.
$\forall\mathcal{C}$ is called the \defn{closure of $\mathcal{C}$ under polynomially bounded universal quantification}.

\begin{theorem}\label{thm:generalcompleteness}
  \printcompletenesstheorem
\end{theorem}

Before proving this theorem, we will provide some immediate corollaries of this general result.

\begin{corollary}
  If $\mathcal{C}$ is a subset of $\PSPACE$ and $\mathcal{C}=\CRAZY$, then $\CEq$ has a complete problem under $\kr$ reductions.
\end{corollary}

\begin{corollary}\label{cor:hardproblems}
  Under polynomial time kernel reductions,
  \begin{enumerate}
  %\item $\EXPEq$ has a complete problem
  \item $\PSPACEEq$ has a complete problem
  \item\label{itm:hardforsigma} $\PKPOPEq$ contains a problem which is hard for $\SKPEq$, for all $k\geq 0$
  \item $\PKPOPEq$ contains a problem which is hard for $\PKPEq$, for all $k\geq 0$
  %\item $\coNPEq$ contains a problem which is hard for $\PEq$
  \end{enumerate}
\end{corollary}
\begin{proof}\mbox{}
  \begin{enumerate}
  %\item $\EXP$ is closed under complement (because it is a deterministic complexity class) and polynomially bounded universal quantification (because we can simulate the universal guess deterministically in exponential time).
  \item $\PSPACE$ is closed under complement (because it is a deterministic complexity class) and polynomially bounded universal quantification (because we can simulate the universal guess deterministically in polynomial space).
  \item If $\mathcal{C}=\SKP$, then the $\kr$-hard problem is in $(\forall(\SKP\cup\mathsf{co}\SKP))\mathsf{Eq}=(\forall(\SKP\cup\PKP))\mathsf{Eq}=\PKPOPEq$.
  \item Same as the previous justification, but starting with $\mathcal{C}=\PKP$.\qedhere
%  \item Same as the previous justification, but starting with $\mathcal{C}=\P$.
  \end{enumerate}
\end{proof}

More specifically, this means that $\coNPEq$ has a problem which is $\kr$-hard for $\PEq$.
\autoref{cor:hardproblems} also implies part 1 of \cite[Theorem~8.7]{bcffm}, which is restated here.

\begin{corollary}[\cite{bcffm}, Theorem~8.7, part 1]
  If $\NP=\coNP$ then $\NPEq$ has a complete problem under polynomial time kernel reductions.
\end{corollary}
\begin{proof}
  If $\NP=\coNP$, then the polynomial hierarchy collapses, and specifically $\mathsf{\Pi_2P}=\mathsf{\Pi_1P}=\coNP=\NP$.
  From \autoref{itm:hardforsigma} in \autoref{cor:hardproblems} we conclude that $\NPEq$ has a $\kr$-hard problem for $\NPEq$.
  Such a problem is by definition $\NPEq$-complete.
\end{proof}

We now return to the proof of \autoref{thm:generalcompleteness} by first providing some motivating ideas.
Recall the canonical complete problem (sometimes called the ``universal'' problem) for $\NP$ (and indeed for various other complexity classes):
\begin{displaymath}
  K = \{\triple{M}{x}{1^t}|M\plain{accepts} x \plain{within} t \plain{steps}\}
\end{displaymath}
The idea of this proof is to adapt this into an equivalence relation $R_K$ consisting of pairs of triples of the form $\pair{\triple{M}{x}{1^{t_x}}}{\triple{M}{y}{1^{t_y}}}$, where $M$ accepts $\pair{x}{y}$, as in the reduction from an arbitrary $\NP$ language to $K$.
The problem we encounter here is that $R_K$ is not necessarily an equivalence relation.
Consider, for example, transitivity, which must be satisfied for all possible pairs of the form $\triple{M}{w}{1^{t_w}}$.
For \emph{arbitrary machines} $M$, just because $M$ accepts $\pair{x}{y}$ and $\pair{y}{z}$ does not necessarily mean that $M$ accepts $\pair{x}{z}$.
The solution is to encode into $R_K$ the requirement that the language which $M$ accepts, $L(M)$, is itself an equivalence relation.
The three properties required of $R_K$ then follow from the properties of $L(M)$.
%
%As a technical consideration for this proof, we point out languages in $\PSPACE$ may be decided by alternating Turing machines which run in polynomial time, so it is permissible to consider polynomially clocked Turing machines.
%
\begin{proof}[Proof of \autoref{thm:generalcompleteness}]
  First we will define a helper algorithm which decides whether a given machine accepts an equivalence relation on strings up to a given length.
  Define the algorithm $A$ as follows on input $\pair{M}{n}$, where $M$ is a polynomially clocked Turing machine of type $\mathcal{C}$ and $n\in\mathbb{N}$:
  \begin{enumerate}
  \item universally guess $a,b,$ and $c\in\Sigma^{\leq n}$
  \item simulate $M$ on $\pair{a}{a}$; if it rejects, reject
  \item simulate $M$ on $\pair{a}{b}$, then on $\pair{b}{a}$; if the former accepts and the latter rejects, reject
  \item simulate $M$ on $\pair{a}{b}$, then on $\pair{b}{c}$, then on $\pair{a}{c}$; if the first two accept and the last one rejects, reject
  \item if execution reaches this point, accept
  \end{enumerate}
  These simulations check that $L(M)$ satisfies reflexivity, symmetry, and transitivity on strings of length at most $n$.
  If $A$ accepts, then the three properties are satisfied, and if it rejects then one of the three properties is violated.
  Since $M$ is a machine of type $\mathcal{C}$, checking if $M$ accepts on some input and if $M$ rejects on some input is in $\mathcal{C}\cup\mathsf{co}\mathcal{C}$.
  The universal guesses of $a,b,$ and $c$ (of length at most $n$) followed by checks of whether the six simulations of $M$ accept or reject place $L(A)$ in the class $\CRAZY$.
  If $p$ is the polynomial which bounds the running time of $M$, then the running time of this algorithm is $6p(|\pair{1^n}{1^n}|)+c$, where $c$ is a constant which represents the time needed to account for the implementation of $A$ (the control of the simulations of $M$, performing logical conjunctions, etc.).
  Hence the running time of $A$ is polynomial in $n$.

  Now we can define the set $R$ by
  \begin{align*}
    R = {} & \{\pair{u}{v}|u=v\} \\
    & \cup \{\pair{\triple{M}{x}{1^{t_x}}}{\triple{M}{y}{1^{t_y}}} |
    \text{1 through 4 below are satisfied}\}
  \end{align*}
  where the conditions are
  \begin{enumerate}
  \item\label{itm:machine} $M$ is a polynomially clocked Turing machine of type $\mathcal{C}$
  \item\label{itm:emx} $A$ accepts $\pair{M}{|x|}$ within $t_x$ steps
  \item\label{itm:emy} $A$ accepts $\pair{M}{|y|}$ within $t_y$ steps
  \item\label{itm:accepts} $M$ accepts $\pair{x}{y}$
  \end{enumerate}
  We claim that $R$ is in $\CRAZYEq$ and $\CEq$-hard.

  First we show that $R\in\CRAZY$.
  By the argument above, $A$ is a $\CRAZY$ algorithm.
  %Since $M$ is a polynomially clocked $\mathcal{C}$ machine by \autoref{itm:machine}, then the simulation of $M$ on $\pair{x}{y}$ in \autoref{itm:accepts} can be performed by a $\mathcal{C}$ algorithm.
  Assuming without loss of generality that $|x|\geq |y|$, if $A$ accepts $\pair{M}{|x|}$ within $t_x$ steps then we know that there is a polynomial time bound on the running time of $M$ on input $\pair{x}{y}$, so simulating it is certainly in $\CRAZY$.
  Finally, testing for equality is in $\mathcal{C}$ by hypothesis so deciding $R$ overall can be performed by a $\CRAZY$ algorithm.

  Next we show that $R$ is an equivalence relation.
  Reflexivity follows from the reflexivity of the equality relation.
  For symmetry, suppose $\pair{\triple{M}{x}{1^{t_x}}}{\triple{M}{y}{1^{t_y}}}\in R$.
  Since \autoref{itm:emx} and \autoref{itm:emy} are true by hypothesis, we know that symmetry on strings of length at most $\max(|x|, |y|)$ in $L(M)$ is satisfied, and that includes the strings $x$ and $y$.
  So since $M$ accepts $\pair{x}{y}$ it must follow that $M$ accepts $\pair{y}{x}$.
  Furthermore, \autoref{itm:machine}, \autoref{itm:emx}, and \autoref{itm:emy} are the same up to symmetry of $x$ and $y$, so we have $\pair{\triple{M}{y}{1^{t_y}}}{\triple{M}{x}{1^{t_x}}}\in R$.
  For transitivity, suppose that both $\pair{\triple{M}{x}{1^{t_x}}}{\triple{M}{y}{1^{t_y}}}\in R$ and $\pair{\triple{M}{y}{1^{t_y}}}{\triple{M}{z}{1^{t_z}}}\in R$.
  Since transitivity is true on strings of length at most $\max(|x|, |y|, |z|)$ by the transitivity propositions checked by \autoref{itm:emx} and \autoref{itm:emy}, and since $M$ accepts both $\pair{x}{y}$ and $\pair{y}{z}$ by hypothesis, it must follow that $M$ accepts $\pair{x}{z}$.
  Again the conditions in \autoref{itm:machine}, \autoref{itm:emx}, and \autoref{itm:emy} are the same.
  We have shown that $R$ is reflexive, symmetric, and transitive, so it is an equivalence relation.
  At this point, we have proven that $R\in\CRAZYEq$.

  Now we need to show that $R$ is $\CEq$-hard.
  Let $S\in\CEq$.
  Suppose $M$ is the polynomially clocked $\mathcal{C}$ machine which decides $S$, and $p$ is the polynomial which bounds the running time of $M$.
  Then the kernel reduction from $S$ to $R$ is $w\mapsto\triple{M}{w}{1^{6p(|\pair{w}{w}|)+c}}$, where $p$ and $c$ are the polynomial and constant described in the first paragraph of this proof.
  Call this reduction $f$.
  The reduction is obviously computable in time polynomial in $|w|$.
  It remains to show that this reduction is correct.

  Suppose $\pair{x}{y}\in S$.
  Now $f(x)=\triple{M}{x}{1^{6p(|\pair{x}{x}|)+c}}$ and $f(y)=\triple{M}{y}{1^{6p(|\pair{y}{y}|)+c}}$.
  \autoref{itm:machine} is true by construction, and \autoref{itm:accepts} is true since $M$ is the machine which decides $S$.
  Assume \autoref{itm:emx} is false.
  Then $M$ does not accept an equivalence relation on strings of length at most $|x|$.
  This is a contradiction, since $M$ decides $S$, an equivalence relation, by hypothesis.
  Therefore \autoref{itm:emx} must be satisfied.
  The same argument applies to \autoref{itm:emy}.
  Hence $\pair{f(x)}{f(y)}\in R$.

  If $\pair{x}{y}\notin S$ then $M$ does not accept $\pair{x}{y}$, since otherwise $\pair{x}{y}$ would be a member of $S$.
  Hence $\pair{x}{y}\notin R$.  
  Therefore we have shown that $R$ is $\CEq$-hard.
\end{proof}

\begin{openproblem}
  Is there a more general characterization of complexity classes which have a $\kr$-hard problem?
\end{openproblem}

\begin{openproblem}
  Under what conditions does a complexity class have a complete problem?
  Can we adapt this idea to create a complete problem for $\PEq$ or $\NPEq$?
\end{openproblem}

\begin{openproblem}
  Can this theorem be used to construct $\krnt$-hard problems for smaller complexity classes like $\NLEq$ under the appropriate time-bounded reduction?
  Larger classes such as $\EXPEq$?
\end{openproblem}

\begin{openproblem}
  To what other equivalence relations does our $\kr$-hard problem reduce?
  Are there ``natural'' $\kr$-hard problems in complexity classes which satisfy the conditions in \autoref{thm:generalcompleteness}?
\end{openproblem}

As an additional corollary, we show that the equivalence relation $R_K$ is necessarily hard given a known hard equivalence relation under $\kr$ reductions.

\begin{corollary}
  Let $\mathcal{C}_1$ be a complexity class and $\mathcal{C}_2$ be a subset of $\PSPACE$ which contains the problem of deciding whether two strings are equal.
  If there exists an equivalence relation $S$ in $\CTEq$ which is hard for $\COEq$ under $\kr$ reductions, then there is an equivalence relation in $\CRAZIEREq$ which is hard for $\COEq$ under $\kr$ reductions.
\end{corollary}
\begin{proof}
  $S\kr R_K$ by the reduction described in the proof of \autoref{thm:generalcompleteness}.
  A similar analysis shows that $R_K\in\CRAZIEREq$.
  Since $S$ is hard for $\COEq$ and polynomial time kernel reductions compose by \autoref{prop:compose}, $R_K$ is also hard for $\COEq$.
\end{proof}

Finally, the following theorem is inspired by Mahaney's theorem, which states that there are no sparse \NP-complete languages unless $\P=\NP$.
Our result concerns not the sparseness of strings in a language, but the sparseness of equivalence classes in an equivalence relation.
This complements the work on ``potential reducibility'', defined in section 5 of \cite{bcffm}.

\begin{definition}[\cite{bcffm}, Definition~7.2]
  Let $R$ and $S$ be equivalence relations on $\Sigma^*$.
  We say $R$ is \defn{potentially reducible} to $S$, denoted $R\pot S$, if there exists a polynomial $p$ such that for all $n\in\mathbb{N}$, the number of equivalence classes in $R$ containing a string of length at most $n$ is at most the number of equivalence classes in $S$ containing a string of length at most $p(n)$.
\end{definition}

It follows from the definitions that for any equivalence relations $R$ and $S$, $R\kr S\implies R\pot S$, and hence $R\npot S \implies R\nkr S$ (this is stated and proven explicitly in \cite[Lemma~5.5]{bcffm}).
As an analog to traditional sparse languages, we provide a definition of ``kernel sparsity'', and show its application to determining potential reducibility and hence kernel reducibility.

\begin{definition}
  An equivalence relation $R$ on $\Sigma^*$ is \defn{kernel sparse} if there exists a polynomial $p$ such that for all $n\in\mathbb{N}$, the number of equivalence classes containing a string of length at most $n$ is at most $p(n)$.
  An equivalence relation is \defn{kernel dense} if it is not sparse, that is if for all polynomials $p$ there exists an $n\in\mathbb{N}$ such that the number of equivalence classes containing a string of length at most $n$ is greater than $p(n)$.
\end{definition}

These definitions allow us to provide the following very natural proposition.
Intuitively, it states that an equivalence relation with many closely packed equivalence classes cannot reduce (under polynomially bounded notions of reduction) to an equivalence relation with few but widely spaced equivalence classes.

\begin{theorem}\label{prop:density}
  Let $R$ and $S$ be equivalence relations on $\Sigma^*$.
  If $R$ is kernel dense and $S$ is kernel sparse, then $R\npot S$ and in particular $R\nkr S$.
\end{theorem}
\begin{proof}
  That $R\npot S$ implies $R\nkr S$ was already stated in the text following the definition of potential reducibility, so it suffices to show that $R\npot S$.

  Assume that $R\pot S$ with the intention of producing a contradiction.
  Let $p$ be the polynomial such that the number of equivalence classes in $R$ containing strings of length at most $n$ is at most the number of equivalence classes in $S$ of length at most $p(n)$ (this is the definition of potential reducibility).
  Let $q$ be the polynomial such that for all $n$ the number of equivalence classes in $S$ containing a string of length at most $n$ is at most $q(n)$ (this is the definition of kernel sparse).
  For each natural number $n$, the number of equivalence classes in $S$ containing a string of length at most $n$ is at most $q(0) + q(1) + \cdots + q(n)$, which is itself bounded above by $nq(n)$ (since $q$ is non-decreasing).
  It follows that the number of equivalence classes in $S$ containing a string of length at most $p(n)$ is bounded above by $p(n)q(p(n))$, which is a polynomial in $n$.
  (This is an overestimate, but we can be generous here and still produce a contradiction.)
  Call this polynomial $r$.

  Let $n_0$ be the natural number such that the number of equivalence classes in $R$ containing a string of length at most $n_0$ is greater than $r(n_0)$.
  Let $C$ be that number of equivalence classes, so $C>r(n_0)$.
  So there are $C$ equivalence classes in $R$ containing strings of length at most $n_0$ (there may be more if there are distinct equivalence classes at smaller lengths) and $r(n_0)$ equivalence classes in $S$ containing strings of length at most $p(n_0)$.
  Specifically there are more equivalence classes in $R$ for strings up to length $n_0$ than there are in $S$ for strings up to length $p(n)$.
  From this we infer that $R$ cannot potentially reduce to $S$, because the number of equivalence classes in $R$ for strings up to length $n_0$ is too great compared to the number of equivalence classes in $S$ for strings up to length $p(n_0)$.
  This is a contradiction with the assumption that $R\pot S$.
  We have shown this for arbitrary polynomials (which came from the definitions of potential reducibility and kernel sparsity), so we can conclude that the result holds for all equivalence relations $R$ and $S$ which are kernel dense and kernel sparse, respectively.
\end{proof}

This places a strong restriction on equivalence relations which are hard (or complete) under polynomial time kernel reductions: they cannot be kernel sparse.

\begin{corollary}
  Let $\CEq$ be a complexity class of equivalence relations containing the equality relation, $R_{eq}=\{\pair{x}{u}|x=y\}$.
  If an equivalence relation $R$ is $\CEq$-hard then it is not kernel sparse.
\end{corollary}
\begin{proof}
  $R_{eq}$ is kernel dense, since it contains $2^n$ equivalence classes at each length $n$---one for each distinct string.
  If $R$ were kernel sparse then $R_{eq}\npot R$ by \autoref{prop:density}.
  This would imply $R_{eq}\nkr R$, which is a contradiction with the hypothesis that all equivalence relations in $\CEq$ (including $R_{eq}$) polynomial time kernel reduce to $R$.
  Therefore $R$ is not kernel sparse.
\end{proof}

%% This last question leads us to briefly note that equivalence of true quantified boolean formulas is a \PSPACE-complete problem; perhaps it is also a \PSPACEEq-complete problem.
%% \begin{proposition}
%%   Define $\QBFEq$ by
%%   \begin{displaymath}
%%     \QBFEq = \{\pair{\phi}{\psi} | \phi \iff \psi\},
%%   \end{displaymath}
%%   where $\phi$ and $\psi$ are fully quantified boolean formulae.
%%   Then $\QBFEq$ is \PSPACE-complete.
%% \end{proposition}
%% \begin{proof}
%%   Suppose $\phi$ denotes $\overline{Q}\tau$, where $\overline{Q}$ represents the sequence of quantified variables and $\tau$ is the boolean formula over those variables.
%%   Then the many-one reduction from $\QBF$ is $\phi\mapsto\pair{\phi}{\exists z\colon\overline{Q}(\tau\land z)}$, where $z$ is a variable not already in $\phi$.
%%   This reduction can obviously be computed in time polynomial in the length of the input, $\phi$.
%%   If $\phi$ is not satisfiable, then no assignment of $z$ makes $\overline{Q}(\tau\land z)$ satisfiable, because $\tau$ will always be false.
%%   Hence $\exists z\colon\overline{Q}(\tau\land z)$ must be false.
%%   If $\phi$ is satisfiable, then choosing $z$ to be true makes $\overline{Q}(\tau\land z)$ true.
%%   Thus $\phi$ is satisfiable if and only if $\exists z\colon\overline{Q}(\tau\land z)$ is satisfiable, so $\QBF\mor\QBFEq$.
%%   Since $\QBFEq$ is clearly decidable in $\PSPACE$, we conclude that $\QBFEq$ is \PSPACE-complete.
%% \end{proof}

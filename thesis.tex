%%%%
%% thesis.tex
%%
%% Copyright 2010 Jeffrey Finkelstein
%%
%% Except where otherwise noted, this work is made available under the terms of
%% the Creative Commons Attribution-ShareAlike 3.0 license,
%% http://creativecommons.org/licenses/by-sa/3.0/.
%%
%% You are free:
%%    * to Share — to copy, distribute and transmit the work
%%    * to Remix — to adapt the work
%% Under the following conditions:
%%    * Attribution — You must attribute the work in the manner specified by
%%    the author or licensor (but not in any way that suggests that they
%%    endorse you or your use of the work).
%%    * Share Alike — If you alter, transform, or build upon this work, you may
%%    distribute the resulting work only under the same, similar or a 
%%    compatible license.
%%    * For any reuse or distribution, you must make clear to others the 
%%    license terms of this work. The best way to do this is with a link to the
%%    web page http://creativecommons.org/licenses/by-sa/3.0/.
%%    * Any of the above conditions can be waived if you get permission from
%%    the copyright holder.
%%    * Nothing in this license impairs or restricts the author's moral rights.
%%%%
%\documentclass{amsart}
\documentclass{article}

% package imports
\usepackage{aliascnt} % for correct autoref labeling of non-theorems
\usepackage[noend, % omit end of block tags
  noline, % omit vertical block lines
  linesnumbered, % number lines
  boxed, % put a box around the algorithm
  oldcommands % newer versions of package have different command names
]{algorithm2e} % for creating pseudocode
\usepackage{amsmath} % for piecewise function definition
\usepackage{amsthm} % for theorems, definitions, lemmas, and styles
\usepackage{amssymb} % for strict subset symbol (\subsetneq)
%\usepackage{chngcntr} % for counting figures with section numbers
\usepackage{complexity} % for typesetting complexity classes
\usepackage{cclicenses} % for adding creative commons license symbols
\usepackage{fullpage} % for making the text take up the full page
\usepackage{graphicx} % for including images
\usepackage[
  backref=page, % backlinks in references
  pdftitle={On the computational complexity of equivalence relations under
    kernel reductions},
  pdfauthor={Jeffrey Finkelstein}
]{hyperref} % for pdf links when rendering \ref and \cite commands
%\usepackage[all]{hypcap} % references to images will link to the image
%\usepackage{multicol} % for list split over multiple columns

% don't print semicolons in pseudocode algorithms
\dontprintsemicolon

% Define theorem, lemma, and definition environments and corresponding styles.
% Lemmata, corollaries, and definitions are numbered with the same counter as
% that for theorems. We have to do some black magic to get the \autoref labels
% to work correctly.
\newtheorem{theorem}{Theorem}[section]

\newaliascnt{lemma}{theorem}
\newtheorem{lemma}[lemma]{Lemma}
\aliascntresetthe{lemma}

\newaliascnt{corollary}{theorem}
\newtheorem{corollary}[corollary]{Corollary}
\aliascntresetthe{corollary}

\newaliascnt{definition}{theorem}
\theoremstyle{definition} \newtheorem{definition}[definition]{Definition}
\aliascntresetthe{definition}

% define lemma, corollary, and definition context labels for \autoref command
% (theorem is already defined)
\newcommand{\lemmaname}{Lemma}
\newcommand{\corollaryname}{Corollary}
\newcommand{\definitionname}{Definition}

% custom shortcut commands
\newcommand{\plain}[1]{\,\text{#1}\,} % plain text inside math environments
\newcommand{\sigmastar}{\Sigma^{*}} % the set of all binary strings
\newcommand{\kr}{\leq^{p}_{ker}} % kernel-reduces
\newcommand{\nkr}{\nleq^{p}_{ker}} % does not kernel-reduce
\newcommand{\krnt}{\leq_{ker}} % kernel-reduces without time bound
\newcommand{\nkrnt}{\nleq_{ker}} % does not kernel-reduce without time bound
\newcommand{\kequiv}{\equiv^{p}_{ker}} % is equivalent under kernel reductions
\newcommand{\kequivnt}{\equiv_{ker}} % is equivalent without time bound
\newcommand{\mor}{\leq^{p}_{m}} % many-one reduces
\newcommand{\moequiv}{\equiv^{p}_m} % is equivalent under many-one reductions
%\newcommand{\tequiv}{\equiv^{p}_T} % is equivalent under Turing reductions
\newcommand{\defn}[1]{\emph{#1}} % emphasize words which are being defined
\newcommand{\pair}[2]{\langle#1,#2\rangle} % pairing function
\newcommand{\triple}[3]{\langle#1,#2,#3\rangle} % generalization of pairing fn.

% create the creative commons license
\newcommand{\license}{\begin{tabular}[h]{r l}
    \bysa & \parbox{275pt}{Copyright 2010 Jeffrey Finkelstein. 
      Except where otherwise noted, this work is licensed
      under http://creativecommons.org/licenses/by-sa/3.0/}
\end{tabular}}

% set commands for \ACCEPT and \REJECT for use in algorithms
\SetKw{ACCEPT}{accept}
\SetKw{REJECT}{reject}

% redefine footnote so it has no reference and no number
\long\def\symbolfootnote#1{\begingroup%
\def\thefootnote{\fnsymbol{footnote}}\footnotetext{#1}\endgroup} 

% change figure numbering so it is per section
%\counterwithin{figure}{section}

% define the author, title, and date
\author{Jeffrey Finkelstein} 
\title{On the computational complexity of equivalence relations under kernel
  reductions}
\date{\today} 

\begin{document}

\maketitle
\symbolfootnote{\license}

\begin{abstract}
  \input{abstract}
\end{abstract}

\section{Introduction}
\input{introduction}
%% Who, what, where, when, why, how!

\section{Preliminaries}

% TODO how formal do these need to be? do i need first defs from BDG?
\begin{definition}
  Let $\Sigma=\{0,1\}$. Then $\sigmastar$ is the set of all strings consisting
  of elements of $\Sigma$. In particular, $\sigmastar$ is the set of all binary
  strings.
\end{definition}

\begin{definition}
  A subset of $\sigmastar$ is called a \defn{language}.
\end{definition}

Since we wish to consider only sets whose members are binary strings, in order
to define sets of pairs of binary strings we need to make use of a
\defn{pairing function}, $\pair{\cdot}{\cdot}\colon
\sigmastar\times\sigmastar\to\sigmastar$. For example, consider the pairing
function defined as follows: $\pair{x}{y}$ duplicates each bit in $x$ and $y$
to produce $\hat{x}$ and $\hat{y}$, respectively, then outputs
$\hat{x}01\hat{y}$. For example, the pair $(0110, 1100)$ can be encoded as
$\pair{0110}{1100}=001111000111110000$.

For tuples of arbitrary fixed length we define the encoding inductively using
the pairing function. For example, the triple $(x,y,z)$ can be encoded as
$\triple{x}{y}{z}=\pair{\pair{x}{y}}{z}$, and so on for tuples with a greater
number of elements.

For a more thorough treatment of languages, alphabets, encodings, pairing
functions, etc., see \cite{bdg95}.

\begin{definition}
  $\P$ is the class of languages for which membership can be decided by a
  Turing machine running in deterministic polynomial time.
  
  $\NP$ is the class of languages for which membership can be decided by a
  Turing machine running in nondeterministic polynomial time.

  $\NP$ can alternately be defined as the class of languages for which
  membership can be verified by a Turing machine running in deterministic
  polynomial time.
\end{definition}

The equivalence of these two definitions of the complexity class $\NP$ can be
found, for example, in \cite{sipser06}.

\begin{definition}
  Let $S$, $T$ be sets, let $S'\subseteq S$, and let $f:S'\to T$ be a
  function. Then $f$ is called a \defn{partial function from $S$ to $T$}. If
  $S'=S$ then $f$ is called a \defn{total function from $S$ to $T$}.
\end{definition}

\begin{definition}
  $\FP$ is the class of total functions computable by a Turing machine running
  in polynomial time. Specifically, $f\colon\mathbb{N}\to\mathbb{N}$ is in
  $\FP$ if there exists a Turing machine which, on input $n$, halts with $f(n)$
  on its tape.
\end{definition}

\begin{definition}
  Let $A,B$ be languages. We say \defn{$A$ polynomial time, many-one reduces to
    $B$} if $\exists f\in\FP:\forall w\in\sigmastar$, $w\in A\iff f(w)\in
    B$. We denote this by $A\mor B$.
  
  We say $A$ \defn{is polynomial time, many-one equivalent to} $B$ if $A\mor
  B$ and $B\mor A$. We denote this by $A\moequiv B$.
\end{definition}

\begin{definition}
  Let $U$ be a set. Let $R\subseteq U\times U$. Then $R$ is an
    \defn{equivalence relation} on $U$ if the following conditions hold:
    \renewcommand{\labelenumi}{\roman{enumi}.}
  \begin{enumerate}
  \item (reflexivity) $\forall x\in U$, $(x, x)\in R$
  \item (symmetry) $\forall x,y\in U$, if $(x,y)\in R$ then $(y,x)\in
    R$
  \item (transitivity) $\forall x,y,z\in U$, if $(x,y)\in R$ and $(y,z)\in R$
    then $(x,z)\in R$
  \end{enumerate}
  If $(x,y)\in R$, we say \defn{$x$ relates to $y$} or \defn{$x$ is equivalent
    to $y$ under $R$}. We denote this by $x\sim_R y$ or $x\sim y$.
\end{definition}

Note that an equivalence relation is a generalization of the idea of equality;
whereas every object is equal to itself and only itself, many objects can be
equivalent with respect to some equivalence relation.

\begin{definition}
  Let $U$ be a set, let $R$ be an equivalence relation on $U$, let $x\in
  U$. The \defn{equivalence class} of $x$ is $[x]_R=\{y\in U|(x,y)\in
  R\}$. When the context is clear, we sometimes omit the subscript, and just
  write $[x]$.
\end{definition}
For all equivalence relations on a set $U$, each element of $U$ is in exactly
one equivalence class and $U=\bigcup_{x\in U}{[x]}$, so the equivalence classes
of an equivalence relation provide a partition of $U$.

In \cite{fg09}, Fortnow and Grochow give a formal definition of a new class of
languages: the class of equivalence problems which can be decided in polynomial
time. They also provide a natural reduction for languages in this complexity
class. We provide the definition, along with its generalization in \NP, here.

\begin{definition}\label{def:peq}
  \defn{\PEq} is the class of equivalence relations for which membership can be
  decided by a Turing machine running in deterministic polynomial time.

  \defn{\NPEq} is the class of equivalence relations for which membership can
  be decided by a Turing machine running in nondeterministic polynomial time.

  \defn{\NPEq} can alternately be defined as the class of equivalence relations
  for which membership can be verified by a Turing machine running in
  deterministic polynomial time.
\end{definition}

Technically, an equivalence relation on $\sigmastar$ is a set of pairs of
binary strings, but $\PEq$ and $\NPEq$ are classes of \emph{languages}, which
are sets of binary strings (not pairs). We use the pairing function discussed
above to encode pairs of binary strings in an equivalence relation (that is,
the binary strings which relate) as single binary strings. For example an
equivalence relation $R\subseteq\sigmastar\times\sigmastar$ can be encoded as a
language $L_R=\{\pair{x}{y}|(x,y)\in R\}$. Then we can discuss membership of
$L_R$ in complexity classes such as $\PEq$ or $\NPEq$, etc. Throughout this
paper, we will abuse these formalities and use the convention that an
equivalence relation is defined as its corresponding encoding described here,
so that we may simply consider equivalence relations as members of complexity
classes, and consider reductions among them.

We explicitly show here the containments among \P, \NP, \PEq, and \NPEq.
\begin{lemma}
  \mbox{} % to put the next item on a new line
  \begin{enumerate}
    \renewcommand{\labelenumi}{\roman{enumi}.}
  \item $\P\subseteq\NP$
  \item $\PEq\subseteq\NPEq$
  \item $\PEq\subsetneq\P$
  \item $\NPEq\subsetneq\NP$
  \end{enumerate}
\end{lemma}
\begin{proof}
  Any language which can be decided in deterministic polynomial time can be
  verified in deterministic polynomial time, by deciding whether the input is
  in the language, thus $\P\subseteq\NP$. The same argument applies to
  equivalence problems, so $\PEq\subseteq\NPEq$.  $\PEq\subseteq\P$ and
  $\NPEq\subseteq\NP$ follows immediately from the definitions. A language in
  $\P$ which is not an equivalence relation is $MAJORITY=\{w|$ the number of
  ones in $w$ is greater than $\frac{|w|}{2}\}$, so $\PEq\subsetneq\P$. In
  fact, if $MAJORITY\in\mathcal{C}$, where $\mathcal{C}$ is any complexity
  class, then \CEq$\neq\mathcal{C}$. $MAJORITY\in\P\subseteq\NP$, therefore
  $\NPEq\subsetneq\NP$.
\end{proof}

\begin{definition}\label{def:kr}
  Let $R$ and $S$ be equivalence relations on $\sigmastar$. We say $R$
  \defn{kernel reduces to} $S$ if $\exists
  f\colon\sigmastar\to\sigmastar:\forall x,y\in\sigmastar$, $\pair{x}{y}\in R
  \iff \pair{f(x)}{f(y)}\in S$. We denote this by $R\krnt S$.
  
  We say $R$ \defn{is kernel equivalent to} $S$ if $R\krnt S$ and $S\krnt
  R$. We denote this by $R\kequivnt S$.

  If $f\in\FP$, then we say $R$ \defn{polynomial time kernel reduces to} $S$,
  and use the notation $R\kr S$ and $R\kequiv S$.
\end{definition}

Note the difference between a kernel reduction and a many-one reduction: a
kernel reduction maps $\pair{x}{y}\in R$ to $\pair{f(x)}{f(y)}\in S$, whereas a
many-one reduction maps $\pair{x}{y}\in R$ to $f(\pair{x}{y})\in S$, for some
polynomial time computable function $f$. Informally, a function which computes
a many-one reduction has access to both $x$ and $y$, but a function which
computes a kernel reduction has access to only one of $x$ and $y$ at a
time. Because the many-one reduction seems to be at least as powerful as the
kernel reduction, we can prove the following lemma, which is essential for
proving \autoref{thm:npeqc_npc}.

\begin{lemma}\label{lem:kr_mor}Let $R,S$ be equivalence relations on
  $\sigmastar$. If $R\kr S$ then $R\mor S$.\end{lemma}
\begin{proof}
  Since $R\kr S$, $\exists f\in\FP:\forall x,y\in\sigmastar$, $\pair{x}{y}\in
  R\iff\pair{f(x)}{f(y)}\in S$. Define $g\in\FP$ by
  $g(\pair{x}{y})=\pair{f(x)}{f(y)}$. Therefore $R\mor S$ by $g$.
\end{proof}

As an analog to polynomial time many-one completeness in \NP, we define a
similar notion of polynomial time completeness under kernel reductions in
\NPEq.

\begin{definition}\label{def:kernel_complete}
  An equivalence relation $R$ is \defn{$\PEq$-complete} if $R\in\PEq$ and
  $\forall S\in\PEq$, $S\kr R$.

  An equivalence relation $R$ is \defn{$\NPEq$-complete} if $R\in\NPEq$ and
  $\forall S\in\NPEq$, $S\kr R$.
\end{definition}

\section{Kernel reductions among feasible equivalence problems}

With these definitions in place, we can now define some examples of equivalence
relations in $\PEq$, feasible equivalence problems.

%% TODO should I make a note about assuming |x|=|y|?
\begin{definition}
  The \defn{parity function}, $\pi\colon \sigmastar\to\{0,1\}$, is defined by
  $\pi(w)=0$ if the number of ones in $w$ is even, and $\pi(w)=1$ if the number
  of ones in $w$ is odd, for all $w\in\sigmastar$.
\end{definition}
\begin{definition}
  $R_{par}=\{\pair{x}{y}|\pi(x)=\pi(y)\}$
\end{definition}
We use the subscript ``$par$'' to denote that pairs of binary strings in this
equivalence relation have the same parity.

\begin{definition}
  The \defn{bitcount function}, $\beta\colon \sigmastar\to\mathbb{N}$, is
  defined by $\beta(w)$ equals the number of ones in $w$, for all
  $w\in\sigmastar$.
\end{definition}
\begin{definition}
  $R_{bc}=\{\pair{x}{y}| \beta(x)=\beta(y)\}$
\end{definition}
We use the subscript ``$bc$'' to denote that pairs of binary strings in this
equivalence relation have the same bitcount.

\begin{definition}
  $R_{eq}=\{\pair{x}{y}|x=y\}$
\end{definition}
$R_{eq}$ is called the \defn{equality relation}.

\begin{definition}
  The \defn{bitwise complement function},
  $\bar\cdot\colon\sigmastar\to\sigmastar$, is defined for all
  $w\in\sigmastar$, where $w=w_1 w_2 \cdots w_{|w|}$, by $\overline{w_i}=0$ if
  $w_i=1$ and $\overline{w_i}=1$ if $w_i=0$, for all $i\leq|w|$.
\end{definition}
\begin{definition}
  $R_{eqc}=\{\pair{x}{y}|x=y$ or $x=\bar{y}\}$
\end{definition}
We use the subscript ``$eqc$'' to denote that pairs of binary strings in this
equivalence relation are either equal or bitwise complements.

\begin{definition}
  The \defn{exclusive or operation},
  $\oplus\colon\sigmastar\times\sigmastar\to\sigmastar$ is defined for all
  $x,y\in\sigmastar$, where $|x|=|y|=n$, $x=x_1 x_2 \cdots x_n$ and $y=y_1 y_2
  \cdots y_n$, by $x_i \oplus y_i=0$ if $x_i=y_i$ and $x_i \oplus y_i=1$ if
  $x_i\neq y_i$, for all $i\leq n$.
\end{definition}
\begin{definition}
  Let $a\in\sigmastar$. $R_{a}=\{\pair{x}{y}|x=y$ or $x\oplus y=a\}$
\end{definition}
Note that $R_{a}$ is a family of equivalence relations. $R_{a}$ is a different
relation for each fixed $a\in\sigmastar$.
%% \begin{definition}
%%   $R_{maj}=\{(x,y)|$ at least half of the bits in both $x$ and $y$ are ones, or
%%   fewer than half of the bits in both $x$ and $y$ are ones$\}$
%% \end{definition}
%% \begin{definition}
%%   Let $k\in\mathbb{N}$. $R_{tk}=\{(x,y)|x$ and $y$ both have at least $k$ ones
%%   or $x$ and $y$ both have fewer than $k$ ones$\}$. (Note that $R_{tk}$ is a
%%   family of equivalence relations; $R_{tk}$ is a different relation for each
%%   fixed $k$. Notice also that if $k=|x|/2$ then $R_{tk}=R_{maj}$.)
%% \end{definition}

Notice the following equivalent definitions, where $n=|x|=|y|=|a|$:
$R_{eq}=\{\pair{x}{y}|x \oplus y = 0^n\}$, $R_{eqc}=\{\pair{x}{y}|x \oplus y =
0^n$ or $x\oplus y = 1^n\}$, and $R_a=\{\pair{x}{y}|x \oplus y = 0^n$ or $x
\oplus y\ = a\}$. From these we can see that if $a=1^n$, then $R_a=R_{eqc}$,
and if $a=0^n$, then $R_a=R_{eq}$.

\subsection{Containments and equivalence classes}

%% TODO show that all the stated equivalence relations are actually eq. rel.s
\begin{theorem}$R_{eq} \subsetneq R_{bc} \subsetneq R_{par}$\end{theorem}
\begin{proof}
  Let $\pair{x, y}\in R_{eq}$, so $x=y$. Then $x$ has exactly the same number
  of ones as $y$ (and the same number of zeros, and in the same order), so
  $\pair{x}{y}\in R_{bc}$. Therefore, $R_{eq} \subset R_{bc}$.
 
  Consider $x=1100$ and $y=0101$. Then $\pair{x}{y}\in R_{bc}$ but $\pair{x}{y}
  \notin R_{eq}$. Therefore $R_{eq} \neq R_{bc}$.

  Let $\pair{x}{y}\in R_{bc}$, so $x$ and $y$ have the same number of ones. Let
  $k$ be the number of ones in $x$, and $l$ be the number of ones in $y$. Then
  $l=k$, which implies $l \equiv k$ (mod 2). Therefore $x$ and $y$ have the
  same parity, so $\pair{x}{y}\in R_{par}$. Therefore $R_{bc} \subset R_{par}$.

  Consider $x=1000$ and $y=1011$. Then $\pair{x}{y}\in R_{par}$ but
  $\pair{x}{y} \notin R_{bc}$. Therefore $R_{bc} \neq R_{par}$.
\end{proof}

\begin{theorem}$R_{eq} \subsetneq R_{eqc}$\end{theorem}
\begin{proof}
  Let $\pair{x}{y}\in R_{eq}$, so $x=y$. Then $\pair{x}{y}$ satisfies the
  property specified in the definition of $R_{eqc}$, specifically that $x=y$,
  so $\pair{x}{y} \in R_{eqc}$. Therefore $R_{eq} \subset R_{eqc}$.

  Consider $x=1000$ and $y=0111$. Then $\pair{x}{y}\in R_{eqc}$ but
  $\pair{x}{y} \notin R_{eq}$. Therefore $R_{eq} \neq R_{eqc}$.
\end{proof}

Since membership in $R_{par}$, $R_{bc}$, $R_{eq}$, $R_{eqc}$, and $R_a$ can be
decided in polynomial time, they are all members of \PEq. Now we can examine
kernel reductions between these members of \PEq. Notice that in each of the
reductions in the next section, the more general equivalence relation reduces
to the more restrictive equivalence relation.

We will here point out that $R_{par}$ is the most general of the above
equivalence relations, and it has only two equivalence classes: $[0]$ and
$[1]$. The only equivalence relation which is more general is the trivial
equivalence relation in which all elements of $\sigmastar$ relate to all other
elements; $\sigmastar$ itself is the only equivalence class of this equivalence
relation. The most restrictive equivalence relation then is the equality
relation, $R_{eq}$, in which each binary string is the sole element in its
equivalence class. The other equivalence relations defined here also have an
infinite number of equivalence classes.

\subsection{Reductions}

We wish to provide some intuition that problems in $\PEq$ under polynomial time
kernel reductions are restricted \emph{not} by the reductions themselves, but
by the number of equivalence classes in the languages. This point becomes
somewhat clearer if we consider a kernel reduction from an equivalence relation
with exactly two equivalence classes (like $R_{par}$) to an equivalence
relation with at least two equivalence classes (like $R_{eq}$). Since we are
allowed polynomial time for the kernel reduction, we can simply \emph{decide}
whether a given word is in one equivalence class or the other, then map it to a
corresponding representative of an equivalence class in the language to which
we are reducing, depending in which of the two equivalence classes the given
word is a member.
%% TODO i know we can do this intuitively when writing an algorithm, but can we
%% ``choose a representative'' algorithmically?
% TODO find an NP problem with two equivalence classes, P=NP?

%% TODO am i allowed to ``choose a representative''?
%% TODO generalize to O(1) equivalence classes?
%% TODO generalize to poly. eq. classes? polynomial in what?
\begin{theorem}\label{thm:two_eq_classes}
  Let $R,S\in\PEq$. Suppose $R$ has exactly two equivalence classes, $[a]$ and
  $[b]$, and $S$ has at least two equivalence classes, including $[j]$ and
  $[k]$. Given $a$, $b$, $j$, and $k$, $R\kr S$.
\end{theorem}
\begin{proof}
  Since $R\in\PEq$, there exists a Turing machine, $M_R$, running in
  deterministic polynomial time such that $\forall x,y\in\sigmastar,
  \pair{x}{y}\in R\iff M_R(\pair{x}{y})$ accepts.

  Construct machine $M\in\FP$ on input $w\in\sigmastar$:\\
  \begin{algorithm}[H]
    \eIf{$M_R(\pair{w}{a})$ accepts}{
      \Return{j}
    }{
      \Return{k}
    }
  \end{algorithm}

  Suppose $\pair{x}{y}\in R$, and without loss of generality, $x,y\in[a]$. Then
  $M(x)=j$ and $M(y)=j$, so $\pair{M(x)}{M(y)}=\pair{j}{j}\in S$.

  Suppose $\pair{x}{y}\notin R$, and without loss of generality, $x\in[a]$ and
  $y\in[b]$. Then $M(x)=j$ and $M(y)=k$. Since equivalence classes form a
  partition, their intersection is empty, so $(j,k)\notin S$. Thus
  $\pair{M(x)}{M(y)}\notin S$.

  Therefore $\pair{x}{y}\in R\iff \pair{M(x)}{M(y)}\in S$, and hence $R\kr S$.
\end{proof}

\begin{corollary}\label{cor:rpar_kr_s}
  Let $S\in\PEq$ be an equivalence relation with at least two equivalence
  classes, including $[j]$ and $[k]$. Given $j$ and $k$, $R_{par}\kr S$.
\end{corollary}
\begin{proof}
  The two equivalence classes of $R_{par}$ are $[0]$ and $[1]$. Use
  \autoref{thm:two_eq_classes} to construct a kernel reduction from $R_{par}$
  to $S$.
\end{proof}

\begin{corollary}
  $R_{par}\kr R_{eq}$
\end{corollary}
\begin{proof}
  Two equivalence classes of $R_{eq}$ are $[0]$ and $[1]$. Use
  \autoref{cor:rpar_kr_s} to construct a kernel reduction from $R_{par}$ to
  $R_{eq}$.
\end{proof}

The kernel reductions we provide below from $R_{par}$ to $R_{bc}$ and then to
$R_{eq}$ somewhat obfuscate this ``decide then map'' process, but that is
essentially what is happening when these reductions are composed.

\begin{theorem}$R_{par}\kr R_{bc}$\end{theorem}
\begin{proof}
  Construct $M\in \FP$ on input $w\in\sigmastar$:\\
  \begin{algorithm}[H]
    \For{$i=1$ \KwTo $|w|-1$}{
      \If{$w_i=1$}{
        \For{$j=i+1$ \KwTo $|w|$}{
          \If{$w_j=1$}{
            write 0 to both $w_i$ and $w_j$\;
            break\;
          }
        }
      }
    }
  \end{algorithm}
  Notice that this is the machine which finds pairs of ones and writes zeros in
  their place, one pair at a time.

  Suppose $\pair{x}{y}\in R_{par}$, so either $x$ and $y$ both have even parity
  or $x$ and $y$ both have odd parity.
  
  If $x$ and $y$ both have even parity, $x$ contains $2k$ ones and $y$ contains
  $2l$ ones, for some $k,l\in\mathbb{N}$. $M(x)$ and $M(y)$ both output the
  string $0^{|x|}$, and since both $M(x)$ and $M(y)$ have a bitcount of zero,
  $\pair{M(x)}{M(y)}\in R_{bc}$.

  If $x$ and $y$ both have odd parity, $x$ contains $2k+1$ ones and $y$
  contains $2l+1$ ones, for some $k,l\in\mathbb{N}$. $M(x)$ and $M(y)$ both
  output a string containing a single one, so both $M(x)$ and $M(y)$ have a
  bitcount of one, $\pair{M(x)}{M(y)}\in R_{bc}$.

  Suppose $\pair{x}{y}\notin R_{par}$, so without loss of generality, $x$ has
  even parity and $y$ has odd parity. Then $x$ contains $2k$ ones and $y$
  contains $2l+1$ ones, for some $k,l\in\mathbb{N}$. Thus $M(x)$ outputs the
  string $0^{|x|}$ and $M(y)$ outputs the string containing a single one. Since
  the bitcount of $M(x)$ is zero and the bitcount of $M(y)$ is one,
  $\pair{M(x)}{M(y)}\notin R_{bc}$.

  Therefore $\pair{x}{y}\in R_{par} \iff \pair{M(x)}{M(y)}\in R_{bc}$, so
  $R_{par} \kr R_{bc}$.
\end{proof}

\begin{theorem}$R_{bc}\kr R_{eq}$\end{theorem}
\begin{proof}
  Construct $M\in \FP$ on input $w\in\sigmastar$, where $w=w_1w_2\cdots
  w_{|w|}$:\\
  \begin{algorithm}[H]
    Sort the bits of $w$\;
    $i\gets1$\;
    \While{$w_i=0$}{
      Write a blank at index $i$\;
      $i\gets i+1$\;
    }
  \end{algorithm}
  Notice that if $w$ contains $k$ ones, this machine outputs the string $1^k$.

  Suppose $\pair{x}{y}\in R_{bc}$, so $x$ and $y$ have the same number of ones,
  say $k$. Thus $M(x)=M(y)=1^k$, so $\pair{M(x)}{M(y)}\in R_{eq}$.
  
  Suppose $\pair{x}{y}\notin R_{bc}$, so $x$ and $y$ have a different number of
  ones. Suppose $x$ has $k$ ones and $y$ has $l$ ones, for some
  $k,l\in\mathbb{N}$, with $k\neq l$. Then $M(x)=1^{k}$ and $M(y)=1^{l}$, so
  $M(x)\neq M(y)$. Thus $\pair{M(x)}{M(y)}\notin R_{eq}$.

  Therefore $\pair{x}{y}\in R_{bc} \iff \pair{M(x)}{M(y)}\in R_{eq}$, so
  $R_{bc}\kr R_{eq}$.
\end{proof}

The equivalence relations $R_{eqc}$, which is a generalization of $R_{eq}$, and
$R_a$, which is a generalization of $R_{eqc}$, also reduce to equality.

\begin{theorem}\label{thm:reqi_req}$R_{eqc}\kr R_{eq}$\end{theorem}
\begin{proof}
  Construct machine $M\in\FP$ on input $w\in\sigmastar$, where
  $w=w_1w_2\cdots w_{|w|}$:\\
  \begin{algorithm}[H]
    \eIf{$w_1=0$}{
      \Return{$w$}
    }{
      \Return{$\bar{w}$}
    }
  \end{algorithm}
  
  Suppose $\pair{x}{y}\in R_{eqc}$, so either $x=y$ or $x=\bar{y}$. In the case
  that $x=y$, $M(x)$ and $M(y)$ produce the same output. In the case that
  $x=\bar{y}$, then either $x_1=1$ and $y_1=0$ or $x_1=0$ and $y_1=1$. Consider
  without loss of generality the case that $x_1=1$ and $y_1=0$. Then $M(x)$
  outputs $\bar{x}$ and $M(y)$ outputs $y$. Now $\bar{x}=\bar{\bar{y}}=y$, so
  $M(x)=M(y)$. Therefore $\pair{M(x)}{M(y)}\in R_{eq}$.

  Suppose $\pair{x}{y}\notin R_{eqc}$, so $x\neq y$ and $x\neq\bar{y}$. 

  In the case that $x_1=0$ and $y_1=0$, then $M(x)=x$ and $M(y)=y$. Since
  $x\neq y$, then $M(x)\neq M(y)$, so $\pair{M(x)}{M(y)}\notin R_{eq}$.

  In the case that $x_1=0$ and $y_1=1$, then $M(x)=x$ and $M(y)=\bar{y}$. Since
  $x\neq\bar{y}$, then $M(x)\neq M(y)$, so $\pair{M(x)}{M(y)}\notin R_{eq}$.

  In the case that $x_1=1$ and $y_1=0$, then $M(x)=\bar{x}$ and $M(y)=y$. Since
  $x\neq\bar{y}$, then $\bar{x}\neq \bar{\bar{y}}=y$, so $M(x)\neq M(y)$, and
  $\pair{M(x)}{M(y)}\notin R_{eq}$. 

  In the case that $x_1=1$ and $y_1=1$, then $M(x)=\bar{x}$ and
  $M(y)=\bar{y}$. Since $x\neq y$, then $\bar{x}\neq\bar{y}$, so $M(x)\neq
  M(y)$, and $\pair{M(x)}{M(y)}\notin R_{eq}$.

  Therefore $\pair{x}{y}\in R_{eqc}\iff \pair{M(x)}{M(y)}\in R_{eq}$, so
  $R_{eqc}\kr R_{eq}$.
\end{proof}

\begin{theorem}Let $a\in\sigmastar$. Then $R_a\kr R_{eq}$.\end{theorem}
\begin{proof}
  Construct machine $M\in\FP$ on input $w\in\sigmastar$, where $|w|=|a|=n$,
  $w=w_1w_2\cdots w_n$ and $a=a_1a_2\cdots a_n$:\\
  \begin{algorithm}[H]
    $s\gets((a_1, w_1), (a_2, w_2), \ldots, (a_n, w_n))$\;
    Perform a stable sort on $s$ with each $a_i$ as the key, to obtain two
    subsequences, $r$ and $r'$, where $r=(a_i, w_i)|_{a_i=0}$ and $r'=(a_j,
    w_j)|_{a_j=0}$\;
    Run the algorithm in \autoref{thm:reqi_req} on the concatenation of each
    $w_j$ in $r'$ to obtain a new string $c$\;
    \Return{the concatenation of each $w_i$, in the order of $r$, with the
      string $c$}
  \end{algorithm}
  Notice that informally this machine splits up the problem into two easier
  problems whose solutions are known: the first problem is the problem of
  determining equality, the second problem is the problem of determining either
  equality or bitwise complement.

  Suppose $\pair{x}{y}\in R_a$, so either $x=y$ or $x\oplus y=a$. In the case
  that $x=y$, then $M(x)$ and $M(y)$ output the same string, so $M(x)=M(y)$,
  and hence $\pair{M(x)}{M(y)}\in R_{eq}$. Now consider the case in which
  $x\oplus y=a$, which implies $x\oplus a=y$ and $y\oplus a=x$. Then $M(x)$ and
  $M(y)$ will first rearrange the bits of $x$ and $y$, respectively, by stable
  sorting the bits of $a$. For all bits of $a$ which are zero, the
  corresponding bits of $x$ and $y$ are equal, by hypothesis. For all bits of
  $a$ which are one, the corresponding bits of $x$ and $y$ are complements of
  one another. Let $a_i$ be the leftmost bit of $a$ which is one. In the case
  that $x_i=1$ and $y_i=0$, then the algorithm from \autoref{thm:reqi_req} will
  flip all the bits of $x$ corresponding to bits of $a$ which are one. Since
  $y$ and $x$ were complements at these bits only, now $M(x)=M(y)$, so
  $\pair{M(x)}{M(y)}\in R_{eq}$. The argument for the case that $x_i=0$ and
  $y_i=1$ is symmetric.

  Suppose $\pair{x}{y}\notin R_a$, so $x\neq y$ and $x\oplus y\neq a$. So
  $\exists i,j\in\{1,2,\ldots,|x|\}: x_i\neq y_i$ and $x_j\oplus y_j\neq
  a_j$. Now $M(x)$ and $M(y)$ will first rearrange the bits of $x$ and $y$,
  respectively, by stable sorting the bits of $a$ in step 2. Call these
  intermediate strings $x'$, $y'$ and $a'$, and the corresponding permutation
  of indices $i$ and $j$ to be $i'$ and $j'$, respectively. Note that the value
  of $a'_{j'}$ completely determines whether $\pair{M(x)}{M(y)}\in R_{eq}$.

  In the case that $a'_{j'}=0$ then $x'_{j'}\oplus y'_{j'}\neq a'_{j'}\implies
  x'_{j'}\oplus y'_{j'}\neq 0\implies x'_{j'}\neq y'_{j'}$ and hence
  $\pair{M(x)}{M(y)}\notin R_{eq}$.

  Consider the case in which $a'_{j'}=1$. Let $k$ be the index of the leftmost
  one bit in $a$, and the index of its image after the stable sorting in step 2
  $k'$. In the case that $x'_{k'}=1$ then $y'_{k'}=x'_{k'}\oplus
  a'_{k'}=1\oplus1=0$. Since $x'_{k'}=1$, step 3 in the above algorithm will
  invert each of the bits of $x'$ from index $k'$ to the end of that
  string. Since $y'_{k'}=0$, step 3 will leave $y'$ unchanged. Since
  $x'_{j'}\oplus y'_{j'}\neq a'_{j'}$ by assumption, then $x'_{j'}\oplus
  y'_{j'}\neq 1\implies x'_{j'}\oplus y'_{j'}=0\implies x'_{j'}=y'_{j'}\implies
  \overline{x'_{j'}}\neq y'_{j'}$. Hence $M(x)\neq M(y)$, so
  $\pair{M(x)}{M(y)}\notin R_{eq}$. The argument for the case that $x'_{k'}=0$
  is symmetric.

  Therefore $\pair{x}{y}\in R_a\iff\pair{M(x)}{M(y)}\in R_{eq}$, so $R_a\kr
  R_{eq}$.
\end{proof}

It appears that all of these ``bitwise'' equivalence problems reduce under
polynomial time kernel reductions to the equality relation, $R_{eq}$, the most
restrictive equivalence relation in \PEq. However, there is evidence\cite{fg09}
that the equality relation is not \PEq-complete. We restate this evidence in
the next section.

We now present theorems formalizing the intuition we have gained about
reductions among equivalence relations with different numbers of equivalence
classes.
\begin{theorem}\label{thm:numbers}
  Let $R$ and $S$ be equivalence relations on $\sigmastar$. Suppose $R$ has $n$
  equivalence classes and $S$ has $m$ equivalence classes. If $n>m$ then
  $R\nkrnt S$ (that is, $R$ does not kernel reduce to $S$, regardless of any
  time bound on the function computing the reduction).
\end{theorem}
\begin{proof}
  Assume with the intention of producing a contradiction that $R\krnt S$. Then
  $\exists f\colon\sigmastar\to\sigmastar:\forall x,y\in\sigmastar$,
  $\pair{x}{y}\in R\iff \pair{f(x)}{f(y)}\in S$.

  Since $R$ has $n$ equivalence classes, each equivalence class is non-empty,
  and the equivalence classes partition $R$, then $\exists
  r_1,\ldots,r_n\in\sigmastar: R=[r_1]_R\cup\cdots\cup[r_n]_R$.  Since each
  element of $R$ is in exactly one equivalence class, $\forall i,j\leq n$,
  $i=j\iff\pair{r_i}{r_j}\in R\iff\pair{f(r_i)}{f(r_j)}\in S$. Therefore the
  image of each $r_i$ is in some equivalence class in $S$.  Also, $\forall
  i,j\leq n$, $i\neq j\iff \pair{r_i}{r_j}\notin R\iff
  \pair{f(r_i)}{f(r_j)}\notin S$. Therefore, the image of each $r_i$ does not
  relate to the image of any other $r_j$, for $i\neq j$, and $i,j\leq
  n$. Therefore each of the equivalence classes $[f(r_1)]_S,\ldots,[f(r_n)]_S$
  is disjoint, so $S$ has at least $n$ equivalence classes. But $n>m$. This is
  a contradiction with the hypothesis that $S$ has $m$ equivalence classes.

  Therefore $R\nkr S$.
\end{proof}

\begin{corollary}
  $R_{eq}\nkrnt R_{par}$
\end{corollary}
\begin{proof}
  $R_{eq}$ has a (countably) infinite number of equivalence classes (one for
  each binary string). $R_{par}$ has two equivalence classes. Therefore these
  equivalence classes meet the conditions of \autoref{thm:numbers}.
\end{proof}

Our intuition now is that the problem of determining whether one equivalence
relation kernel reduces to another reduces to the problem of determining
representatives of equivalence classes in both equivalence relations.

\begin{theorem}\label{thm:repr_kr}
  Let $R,S$ be equivalence relations. Suppose $R\in\PEq$. Suppose $R$ has a
  finite number of equivalence classes, $n$, and the number of equivalence
  classes of $S$ is greater than or equal to $n$ (possibly countably
  infinite). Let $REP(R)$ be a set of representatives of equivalence classes in
  $R$, and $REP(S)$ be a set of representatives of equivalence classes in $S$.
  If $\exists f\colon REP(R)\to REP(S)$ such that $f\in\FP$ and $f$ is
  injective, then $R\kr S$.
\end{theorem}
\begin{proof}
  Since $R\in\PEq$, $\exists M_R$, a deterministic Turing machine running in
  polynomial time, such that $\pair{x}{y}\in R\iff M_R(\pair{x}{y})$
  accepts. Construct $M\in\FP$ on input $w\in\sigmastar$:\\
  \begin{algorithm}[H]
    \For{$r_i\in REP(R)$}{
      \If{$M_R(\pair{w}{r_i})$ accepts}{
        \Return{$f(r_i)$}
      }
    }
  \end{algorithm}
  Notice that each $w\in\sigmastar$ is in exactly one equivalence class in $R$,
  because the equivalence classes partition $\sigmastar$, so
  $M_R(\pair{w}{r_i})$ accepts exactly once when $\pair{w}{r_i}\in R$.

  Suppose $\pair{x}{y}\in R$, so $\pair{x}{r_i}\in R$ and $\pair{y}{r_i}\in R$
  for some $r_i\in REP(R)$. Then $M(x)$ outputs $f(r_i)$ and $M(y)$ outputs
  $f(r_i)$. Since $\pair{f(r_i)}{f(r_i)}\in S$, then $\pair{M(x)}{M(y)}\in S$.

  Suppose $\pair{x}{y}\notin R$. So $\exists r_i, r_j\in REP(R)$, with $r_i\neq
  r_j$, such that $\pair{x}{r_i}\in R$ and $\pair{y}{r_j}\in R$. Then $M(x)$
  outputs $f(r_i)$ and $M(y)$ outputs $f(r_j)$. Since $f$ is injective,
  $r_i\neq r_j\implies f(r_i)\neq f(r_j)$. Since $f(r_i)$ and $f(r_j)$ are
  distinct elements in $REP(S)$, they are representatives of two distinct
  equivalence classes. Since every element of $S$ is in exactly one equivalence
  class, and since $[f(r_i)]\neq[f(r_j)]$, it follows that
  $\pair{f(r_i)}{f(r_j)}=\pair{M(x)}{M(y)}\notin S$.

  Therefore $\pair{x}{y}\in R\iff \pair{M(x)}{M(y)}\in S$, so $R\kr S$.
\end{proof}

\begin{theorem}
  Let $R,S$ be equivalence relations. Suppose $R\in\PEq$. Suppose $R$ has a
  finite number of equivalence classes, $n$, and the number of equivalence
  classes of $S$ is greater than or equal to $n$ (possibly countably
  infinite). If $\exists E_R,E_S\in\FP$ and $\exists i,j\in\sigmastar$ such
  that $E_R$ on input $i$ outputs the encoding of $REP(R)$ and $E_S$ on input
  $j$ outputs the encoding of at least $n$ elements of $REP(S)$, then $R\kr S$.
\end{theorem}
\begin{proof}
  We compute the kernel reduction using the following procedure.

  Run $E_R$ on input $i$ to produce the encoding of $REP(R)$. The output of
  this machine is $\langle r_1, r_2, \ldots, r_n\rangle$, where $r_1,\dots,r_n$
  are representatives of the equivalence classes in $R$.

  Run $E_S$ on input $j$ to produce the encoding of at least $n$ elements of
  $REP(S)$. The length of the output of $E_S$ on input $j$ is bounded by some
  polynomial in the length of $j$, say $p(|j|)$. Since $p(|j|)$ is finite, then
  the number of elements of $REP(S)$ which $E_S$ outputs when run on input $j$
  must be finite. Call this number $m$. By hypothesis $m\geq n$. So the output
  of this function is $\langle s_1, s_2, \ldots, s_m\rangle$, where
  $s_1,\ldots, s_m$ are representatives of $m$ equivalence classes in $S$.

  Define $f\in\FP$ by $f(r_l)=s_l$, for all $l\leq n$. We now wish to show that
  $f$ is injective. Suppose $r_l,r_q\in R$ and $r_l\neq r_q$. Then $f(r_l)=s_l$
  and $f(r_q)=s_q$. Since each element in the encoding of $m$ elements of
  $REP(S)$ which is output by $E_S$ on input $j$ is unique (as each
  representative is in its own equivalence class), $s_l\neq s_q$, and hence
  $f(r_l)\neq f(r_q)$. Therefore $f$ is injective.

  The function $f$ now satisfies the conditions in the hypothesis of
  \autoref{thm:repr_kr}, so the result follows.
\end{proof}

%% TODO Equality is in AC^0, right? But majority and parity are not in AC^0.

% To provide more evidence we will next examine an equivalence problem in $\P$
% that is not explicitly a problem involving the examination of bits in a
% string.

%% \begin{definition}
%%   Let $T_1=(V_1, E_1, r_1), T_2=(V_2, E_2, r_2)$, with $r_1\in V_1$ and $r_2\in
%%   V_2$, be rooted trees. Then $T_1$ is \defn{isomorphic to} $T_2$ if
%%   $\exists\phi:V_1\to V_2:\phi(r_1)=r_2$ and $(u,v)\in E_1\iff(\phi(u),
%%   \phi(v))\in E_2$.
%% \end{definition}
%% \begin{definition}
%%   $TI=\{(T_1,T_2)|T_1$ is isomorphic to $T_2\}$
%% \end{definition}
%% Informally, two trees are isomorphic if there is a permutation of the vertices
%% of one tree which preserves edges in the other tree and preserves the root
%% node.

%% The tree isomorphism problem is in $\P$, and in fact, easier than \P. For a
%% linear time algorithm for deciding isomorphism of trees see \cite{ahu74}, and
%% for an alternating logarithmic time algorithm see \cite{buss97}.

%% TODO tree canonization is in CF(FALOGTIME)\subset CF(P)
%% TODO do the tree isomorphism algorithms reduce to equality?
\subsection{Complete invariants}
\begin{definition}
  Let $R$ be an equivalence relation on $A$, and let $f\colon A\to A$. Then $f$
  is a \defn{complete invariant} for $R$ if $(x,y)\in R$ if and only if
  $f(x)=f(y)$.
\end{definition}
\begin{definition}
  $\FPKer=\{L|L$ is an equivalence relation on $\sigmastar$ with a complete
  invariant in $\FP\}$
\end{definition}

\begin{lemma}\label{lem:ker_peq}
  $\FPKer\subseteq\PEq$
\end{lemma}
\begin{proof}
  Let $R\in\FPKer$. Then by definition $\exists f\in\FP: \pair{x}{y}\in R\iff
  f(x)=f(y)$. To decide membership of $\pair{x}{y}\in\R$, use $f$ to decide
  whether $f(x)=f(y)$. This is true if and only if $\pair{x}{y}\in
  R$. Therefore membership in $R$ can be decided in polynomial time, hence
  $\FPKer\subseteq\PEq$.
\end{proof}

For the sake of clarity, we provide a proof of the following claim made by
Fortnow and Grochow:

\begin{theorem}
  $\FPKer=\PEq$ if and only if $R_{eq}$ is \PEq-complete.
\end{theorem}
\begin{proof}
  For the forward direction, suppose $\FPKer=\PEq$. Let $S\in\PEq=\FPKer$, so
  $\exists f\in\FP: \pair{x}{y}\in S\iff f(x)=f(y)\iff \pair{f(x)}{f(y)}\in
  R_{eq}\iff S\kr R_{eq}$. Thus $R_{eq}$ is \PEq-complete.

  Conversely, suppose $R_{eq}$ is \PEq-complete. Then $\forall S\in\PEq$,
  $\exists f\in\FP:\pair{x}{y}\in S\iff\pair{f(x)}{f(y)}\in R_{eq}\iff
  f(x)=f(y)$. Thus $f$ is a complete invariant for $S$ computable in polynomial
  time. Thus $S\in\FPKer$, and hence $\PEq\subseteq\FPKer$. By
  \autoref{lem:ker_peq}, $\FPKer\subseteq\PEq$, therefore $\PEq=\FPKer$.
\end{proof}

%% TODO what happens if UP is a subset of BQP?
%% TODO define UP and BQP?
Fortnow and Grochow provide evidence that $R_{eq}$ is \emph{not} \PEq-complete,
by showing that if $\FPKer=\PEq$ then $\UP\subseteq\BQP$ \cite{fg09}. To
separate $\PEq$ from $\FPKer$, we need to exhibit an equivalence problem for
which membership can be decided in polynomial time, but no polynomial time
algorithm exists for computing a complete invariant, or equivalently, no
reduction to the equality relation exists. Two such candidates identified by
Fortnow and Grochow are the Boolean function congruence problem and the
subgroup equivalence problem.

%% TODO say something else about candidates

\subsection{Completeness}
%% TODO P-completeness is for log-space reductions, right?  

It would appear that proving some language \PEq-complete should be easier than
proving, for example, \P-completeness directly, because the kernel reduction
allows us a polynomial time computable function, even in the set of equivalence
problems \emph{decidable} in polynomial time, whereas proofs for
\P-completeness under many-one reductions allow only logarithmic space. This
means we are allowed to examine the entire computation history of the machine
which decides any language in $\PEq$ (for example, as the tableau of the
deterministic polynomial time machine). And from our examination of reductions
among feasible equivalence problems, we can see that some reductions seem to
solve the problem to be reduced first. This provides some intuition that
polynomial time kernel reductions for problems in $\PEq$ may be too
powerful. Again, the real restriction here is on the number of equivalence
classes in each language.

%% TODO restate FG09 Thm 4.3 If Ker=PEq then UP\subseteq BQP,  Cor 4.8 (pf?)
%% note: this is apparently evidence that PEq is not equal to Ker

%% TODO showing completeness of a problem should be somewhat easier because we
%% are allowed to examine the entire computation history

\section{Kernel reductions among intractable problems}

\subsection{The graph isomorphism problem}

An equivalence problem of particular importance is the graph isomorphism
problem. Although it is in \NP, it is not known to be \NP-complete and it is
not known to be in \P. It is therefore a candidate for $\NP\backslash\P$ (if
$\P\neq\NP$). Since it is an equivalence problem in \NP, it is a member of
\NPEq, so it may be of particular value to study kernel reductions to and from
the graph isomorphism problem. 

\begin{definition}
  Let $V$ be a finite set, let $E$ be a collection of subsets of $V$ of size
  exactly 2. Then $G=(V, E)$ is called an \defn{undirected graph}. Elements of
  $V$ are called \defn{vertices}, and elements of $E$ are called \defn{edges}.

  If instead $E\subseteq V\times V$, then $G=(V, E)$ is a \defn{directed
    graph}.
\end{definition}
\begin{definition}
  Let $G_1=(V_1,E_1)$ and $G_2=(V_2, E_2)$ be undirected graphs. Then $G_1$ is
  \defn{isomorphic to} $G_2$ if $\exists \phi\colon V_1\to V_2:\{u,v\}\in
  E_1\iff \{\phi(u), \phi(v)\}\in E_2$ and $\phi$ is a bijection.

  If $G_1=(V_1,E_1)$ and $G_2=(V_2, E_2)$ are directed graphs, then $G_1$ is
  \defn{isomorphic to} $G_2$ if $\exists \phi\colon V_1\to V_2:(u,v)\in E_1\iff
  (\phi(u), \phi(v))\in E_2$ and $\phi$ is a bijection.
\end{definition}
Intuitively, the bijection $\phi$ is a relabeling of vertices of $G_1$ which
preserves adjacency in $G_2$.

\begin{definition}
  Let $GI=\{\pair{G_1}{G_2}|G_1$ and $G_2$ are undirected graphs and $G_1$ is
  isomorphic to $G_2\}$. Deciding membership in $GI$ is the \defn{graph
    isomorphism problem}.

  Let $DirGI=\{\pair{G_1}{G_2}|G_1$ and $G_2$ are directed graphs and $G_1$ is
  isomorphic to $G_2\}$. Deciding membership in $DirGI$ is the \defn{directed
    graph isomorphism problem}.
\end{definition}

\subsection{Kernel reductions to graph isomorphism}
We begin by examining kernel reductions from the $\PEq$ equivalence relations
defined above to the graph isomorphism problem. The reductions should
intuitively be easy because the graph isomorphism problem is (seemingly) of
greater complexity. We examine these upward reductions in order to gain some
intuition that a kernel reduction makes sense, practically.

%% TODO this may not be an allowable proof
\begin{theorem}\label{thm:rpar_gi}$R_{par}\kr GI$\end{theorem}
\begin{proof}
  Construct $M\in \FP$ on input $w\in\sigmastar$:\\
  \begin{algorithm}[H]
    $V_w\gets\{v_p, v_o\}$\;
    $E_w\gets\{\}$\;
    \For{$i=1$ \KwTo $|w|$}{
      \If{$w_i=1$}{
        \eIf{$\{v_o, v_p\}\in E_w$}
            {add $\{v_o, v_p\}$ to $E_w$\;}
            {remove $\{v_o, v_p\}$ from $E_w$\;}
      }
    }
    \Return $G_w=(V_w, E_w)$
  \end{algorithm}

  Suppose $\pair{x}{y}\in R_{par}$, so either $x$ and $y$ both have even parity
  or $x$ and $y$ both have odd parity.

  If $x$ and $y$ both have even parity, $x$ contains $2k$ ones and $y$ contains
  $2l$ ones, for some $k,l\in\mathbb{N}$. Since $2k$ is even, machine $M$ on
  input $x$ adds then removes the edge $\{v_o, v_p\}$ to and from $E_x$ an
  equal number of times. Similarly for $M$ on input $y$. Therefore $M(x)$
  outputs $G_x=(V_x, E_x)$, where $V_x=\{v_o, v_p\}$ and $E_x=\{\}$, and $M(y)$
  outputs $G_y=(V_y, E_y)$, where $V_y=\{v_o, v_p\}$ and $E_y=\{\}$. Then $G_x$
  is isomorphic to $G_y$ by the identity function, $I\colon V_x\to V_y$,
  defined by $I(v)=v, \forall v\in V_x$.

  If $x$ and $y$ both have odd parity, $x$ contains $2k+1$ ones and $y$
  contains $2l+1$ ones, for some $k,l\in\mathbb{N}$. Since $2k+1$ is odd,
  machine $M$ on input $x$ adds edge $\{v_o, v_p\}$ to $E_x$ one more time than
  it removes the edge. Similarly for $M$ on input $y$. Therefore $M(x)$ outputs
  $G_x=(V_x, E_x)$, where $V_x=\{v_o, v_p\}$ and $E_x=\{\{v_o, v_p\}\}$, and
  $M(y)$ outputs $G_y=(V_y, E_y)$, where $V_y=\{v_o, v_p\}$ and $E_y=\{\{v_o,
  v_p\}\}$. Then $G_x$ is isomorphic to $G_y$ by the identity function,
  $I\colon V_x\to V_y$, defined by $I(v)=v, \forall v\in V_x$.

  Suppose $\pair{x}{y}\notin R_{par}$, so without loss of generality, $x$ has
  even parity and $y$ has odd parity. Then $x$ contains $2k$ ones and $y$
  contains $2l+1$ ones, for some $k,l\in\mathbb{N}$. Since $2k$ is even,
  machine $M$ on input $x$ adds then removes the edge $\{v_o, v_p\}$ to and
  from $E_x$ an equal number of times. Since $2l+1$ is odd, machine $M$ on
  input $y$ adds edge $\{v_o, v_p\}$ to $E_y$ one more time than it removes the
  edge. Therefore $M(x)$ outputs $G_x=(V_x, E_x)$, where $V_x=\{v_o, v_p\}$ and
  $E_x=\{\}$, and $M(y)$ outputs $G_y=(V_y, E_y)$, where $V_y=\{v_o, v_p\}$ and
  $E_y=\{\{v_o, v_p\}\}$. Since $\{v_o, v_p\}\in E_y$ but $\{v_o, v_p\}\notin
  E_x$, so no bijection exists between $V_x$ and $V_y$ which preserves
  edges. Therefore, $G_x$ is not isomorphic to $G_y$ so
  $\pair{M(x)}{M(y)}\notin GI$.

  Therefore $\pair{x}{y}\in R_{par} \iff \pair{M(x)}{M(y)} \in GI$, so $R_{par}
  \kr GI$.
\end{proof}

\begin{theorem}\label{thm:rbc_gi}$R_{bc}\kr GI$\end{theorem}
\begin{proof}
  Construct $M\in \FP$ on input $w \in \sigmastar$:\\
  \begin{algorithm}[H]
    $V_w\gets\{v_1, v_2, \ldots, v_{|w|}, v_{zero}, v_{one,0}, v_{one,1},
    v_{one,2}\}$\;
    $E_w\gets\{\{v_{one,0}, v_{one,1}\}, \{v_{one,1}, v_{one,2}\}, \{v_{one,2},
    v_{one,0}\}\}$\;
    \For{$i=1$ \KwTo $|w|$}{
      \eIf{$w_i=1$}{
        add $\{v_i, v_{one,0}\}$ to $E_w$\;
      }{
        add $\{v_i, v_{zero}\}$ to $E_w$\;
      }
    }
    \Return{$G_w=(V_w, E_w)$}
  \end{algorithm}
  
  Suppose $\pair{x}{y}\in R_{bc}$, so $x$ and $y$ have the same number of ones,
  say $k\in\mathbb{N}$. Assume $|x|=|y|=n$, so both $x$ and $y$ have $n-k$
  zeros. Define $E_{w,1}=\{\{v_i, v_{one,0}\}|i\in\{1,2,\ldots,n\}, w_i = 1\}$
  and $E_{w,0}=\{\{v_i, v_{zero}\}|i\in\{1,2,\ldots,n\}, w_i = 0\}$, so $E_x =
  E_{x,1}\cup E_{x,0}$ and $E_y = E_{y,1} \cup E_{y,0}$ by construction. Define
  $V_{w,b}=\{v_i|w_i=b\}$, so $V_x=V_{x,1} \cup V_{x,0}$ and $V_y=V_{y,1} \cup
  V_{y,0}$. Note that $|V_{x,1}|=|V_{y,1}|=k$ and
  $|V_{x,0}|=|V_{y,0}|=n-k$. Since $|V_{x,1}|=|V_{y,1}|=k$, there exists a
  bijection between them, call it $\phi_1\colon V_{x,1}\to V_{y,1}$. Similarly,
  since $|V_{x,0}|=|V_{y,0}|=k$, there exists a bijection between them, call it
  $\phi_0\colon V_{x,0}\to V_{y,0}$. Define $\phi\colon V_x\to V_y$ by
  \begin{displaymath}
    \phi(v) = 
    \begin{cases}
      \phi_0(v) & \plain{if} v = v_i \plain{and} x_i = 1, \plain{for some}
      i\in\{1,\ldots,n\}\\ 
      \phi_1(v) & \plain{if} v = v_i \plain{and} x_i = 0, \plain{for some}
      i\in\{1,\ldots,n\}\\ 
      v & \plain{if} v \in \{v_{zero}, v_{one,0}, v_{one,1}, v_{one,2}\}
    \end{cases}
  \end{displaymath}
  for all $v\in V_x$. Notice that each $v_i$ ``corresponds'' to a
  single $x_i$, because each $x_i$ can be either a one or a zero,
  exclusively.

  Since the only edges in $E_x$ are the edges $\{v_i, v_{one,0}\}$ when $x_i=1$
  and $\{v_i, v_{zero}\}$ when $x_i=0$, then
  \begin{displaymath}
    (v_i, v_{one,0})\in E_x \iff (\phi(v_i), \phi(v_{one,0}))=(\phi_1(v_i),
    v_{one,0})\in E_y
  \end{displaymath}
  and 
  \begin{displaymath}
    (v_i, v_{zero})\in E_x \iff (\phi(v_i), \phi(v_{zero})) = (\phi_0(v_i),
    v_{zero})\in E_y
  \end{displaymath}
  Therefore $\phi$ describes a graph isomorphism, so $G_1$ is isomorphic to
  $G_2$.
  
  Suppose $\pair{x}{y}\notin R_{bc}$, so $x$ and $y$ have a different number of
  ones. Let $k$ be the number of ones in $x$, and $l$ be the number of ones in
  $y$, with $k\neq l$. Suppose without loss of generality that $k>l$. Define
  $E_{w,0}$ and $E_{w,1}$ as above. Now $|E_{x,1}|=k$ and $|E_{y,1}|=l$. Since
  $k>l$, $E_{x,1}$ has at least one more edge adjacent to the triangle created
  by the vertices $\{v_{one,0},v_{one,1},v_{one,2}\}$ than does $E_{y,1}$. Thus
  no possible bijection exists between $V_x$ and $V_y$ which preserves all
  edges. Thus $G_x$ is not isomorphic to $G_y$, so $\pair{M(x)}{M(y)}\notin
  GI$.

  Therefore $\pair{x}{y}\in R_{bc} \iff \pair{M(x)}{M(y)}\in GI$, so $R_{bc}\kr
  GI$.
\end{proof}

Unlike the reductions from $R_{par}$ and $R_{bc}$ to $GI$, in the reductions
from $R_{eq}$, $R_{eqc}$, and $R_a$ to $GI$ the order of bits in each string
$x$ and $y$ is significant. As such, it may be easier to create kernel
reductions from these equivalence relations to the directed graph isomorphism
problem, which we can prove equivalent under kernel reductions to the graph
isomorphism problem. 

\begin{lemma}[\cite{kst93} and \cite{miller77}]\label{lem:gi_ke_dirgi}
  $GI\kequiv DirGI$
\end{lemma}
\begin{proof}
  To show $GI\kr DirGI$, replace each undirected edge in the graph with a pair
  of complementary directed edges.
  
  To show $DirGI\kr GI$, replace each directed edge in the graph with a set of
  vertices and edges that enforces an ordering between the vertices. In
  \cite{miller77}, for example, when given vertices $x$ and $y$ with directed
  edge $(x,y)$, the author adds the vertices $\{v_1, v_2, \ldots, v_7\}$ with
  undirected edges $\{\{x, v_1\}, \{v_1,v_4\}, \{v_4,y\}, \{v_1,v_2\},
  \{v_2,v_3\}, \{v_4,v_5\}, \{v_5,v_6\}, \{v_6,v_7\}\}$.
\end{proof}

From \autoref{lem:gi_ke_dirgi}, we can use a kernel reduction to the directed
graph isomorphism problem to show that a language kernel reduces to the
undirected graph isomorphism problem, as in the following theorems.

\begin{theorem}\label{thm:req_kr_dirgi}$R_{eq} \kr DirGI$\end{theorem}
\begin{proof}
  Construct machine $M\in\FP$ on input $w\in\sigmastar$:\\
  \begin{algorithm}[H]
    $V_w\gets\{v_1, v_2, \ldots, v_{|w|}\}$\; 
    $E_w\gets\{(v_1, v_2), (v_2, v_3), \ldots, (v_{|w|-1},
    v_{|w|})\}$\tcp*[f]{directed edges}\;
    \For{$i=1$ \KwTo $|w|$}{
      \If{$w_i=1$}{
        add vertex $v'_i$ to $V_w$\;
        add directed edge $(v_i, v'_i)$ to $E_w$\;
      }
    }
    \Return{$G_w=(V_w, E_w)$}
  \end{algorithm}
  Notice that this machine constructs a ``spine'' of vertices, with an extra
  vertex $v'_i$ and directed edge $(v_i, v'_i)$ adjacent to the spine whenever
  $w_i$ is a one, $\forall i\in\{1,2,\ldots,|w|\}$.

  Suppose $\pair{x}{y}\in R_{eq}$, so $x=y$. Then $M(x)$ and $M(y)$ produce the
  same graph, so $G_x$ is isomorphic to $G_y$ by the identity
  mapping. Therefore $\pair{M(x)}{M(y)}\in DirGI$.
  
  %% TODO is this sufficient proof?

  Suppose $\pair{x}{y}\notin R_{eq}$, so $x\neq y$. Suppose $|x|=|y|=n$. Run
  $M$ on input $x$ to yield $G_x=(V_x, E_x)$, and run $M$ on input $y$ to yield
  $G_y=(V_y, E_y)$. Since the graphs are directed, the ``spine'' created by the
  vertices $\{v_1, v_2, \ldots, v_n\}$ and the edges $\{(v_1, v_2), (v_2, v_3),
  \ldots, (v_{n-1}, v_n)\}$ must correspond in both $G_x$ and $G_y$. Let $i$ be
  the index of the first bit at which $x$ and $y$ differ. Suppose without loss
  of generality that $x_i=1$ and $y_i=0$. Then $v'_i\in V_x$ and $(v_i,
  v'_i)\in E_x$, but $v'_i\notin V_y$ so $(v_i, v'_i)\notin E_y$. Assume with
  the intention of producing a contradiction that a bijection exists between
  $V_x$ and $V_y$ which satisfies the conditions for a graph isomorphism. Since
  vertices along the ``spine'' of the $V_x$ must map to vertices along the
  ``spine'' of $V_y$, and specifically $v_i$ in $V_x$ must map to $v_i$ in
  $V_y$, $(v_i, v'_i)\in E_x$ implies $(v_i, v'_i)\in E_y$. But $(v_i,
  v'_i)\notin E_y$ because $y_i=0$. This is a contradiction. Therefore no such
  mapping exists, so $G_x$ is not isomorphic to $G_y$, and hence
  $\pair{M(x)}{M(y)}\notin DirGI$.

  Therefore $\pair{x}{y}\in R_{eq} \iff \pair{M(x)}{M(y)}\in DirGI$, so
  $R_{eq}\kr DirGI$.
\end{proof}

\begin{corollary}$R_{eq}\kr GI$\end{corollary}
\begin{proof}Follows directly from \autoref{thm:req_kr_dirgi} and
  \autoref{lem:gi_ke_dirgi}.\end{proof}

\begin{theorem}\label{thm:reqi_kr_dirgi}$R_{eqc}\kr DirGI$\end{theorem}
\begin{proof}
  Construct machine $M\in \FP$ on input $w\in\sigmastar$:\\
  \begin{algorithm}[H]
    $V_w\gets\{v_1, v_2, \ldots, v_{|w|}, v_{zero}, v_{one}\}$\;
    $E_w\gets\{(v_1, v_2), (v_2, v_3), \ldots, (v_{|w|-1},
    v_{|w|})\}$\tcp*[f]{directed edges}\;
    \For{$i=1$ \KwTo $|w|$}{
      \eIf{$w_i=1$}{
        add directed edge $(v_i, v_{one})$ to $E_w$
      }{
        add directed edge $(v_i, v_{zero})$ to $E_w$
      }
    }
    \Return{$G_w=(V_w, E_w)$}
  \end{algorithm}
  Notice that this machine, as in the machine in the proof of
  \autoref{thm:req_kr_dirgi}, creates a ``spine'' representing each bit of word
  $w$.

  Suppose $\pair{x}{y}\in R_{eqc}$, so either $x=y$ or $x=\bar{y}$.

  In the case that $x=y$, $M(x)$ and $M(y)$ output exactly the same graph, so
  $G_x$ is isomorphic to $G_y$, and hence $\pair{M(x)}{M(y)}\in DirGI$.

  In the case that $x=\bar{y}$, define $\phi\colon V_x\to V_y$ by
  \begin{displaymath}
    \phi(v)=
    \begin{cases}
      v & \plain{if} v = v_i, \plain{for some} i\in\{1, 2, \ldots, |x|\}\\
      v_{zero} & \plain{if} v = v_{one}\\
      v_{one} & \plain{if} v = v_{zero}
    \end{cases}
  \end{displaymath}
  for all $v\in V_x$. Notice that $\phi$ maps each $v_i\in V_x$ to the
  corresponding $v_i\in V_y$, and maps $v_{zero}\in V_x$ to $v_{one}\in V_y$
  and $v_{one}\in V_x$ to $v_{zero}\in V_y$. Then $\forall
  i\in\{1,2,\ldots,|x|\}$, $x_i=0 \iff y=1$, so $(v_i, v_{zero})\in E_x \iff
  (\phi(v_i), \phi(v_{zero})) = (v_i, v_{one})\in E_y$. Similarly, $x_i=1 \iff
  y=0$, so $(v_i, v_{one})\in E_x \iff (\phi(v_i), \phi(v_{one}))\in E_y \iff
  (v_i, v_{zero})\in E_y$. The rest of the edges in $E_x$ map directly to the
  corresponding edges in $E_y$ by $(v_{i-1}, v_i) \mapsto (\phi(v_{i-1}),
  \phi(v_i))=(v_{i-1}, v_i)$, $\forall i\in\{2,3,\ldots,|x|\}$. Therefore,
  $\phi$ describes an isomorphism between $G_x$ and $G_y$, so
  $\pair{M(x)}{M(y)}\in DirGI$.

  Suppose $\pair{x}{y}\notin R_{eqc}$, so $x\neq y$ and $x\neq\bar{y}$. Thus
  $\exists i,j\in\{1,2,\ldots,|x|\}, i\neq j,$ such that $x_i=y_i\land x_j\neq
  y_j$. Suppose without loss of generality that $x_i=y_i=0$ and $0=x_j\neq
  y_j=1$. Now $x_i=y_i=0$ implies $(v_i, v_{zero})\in E_x$ and $(v_i,
  v_{zero})\in E_y$. Also, $x_j=0$ implies $(v_j, v_{zero})\in E_x$ and $y_j=1$
  implies $(v_j, v_{one})\in E_y$. Assume, with the goal of producing a
  contradiction, that there exists a bijection, $\phi\colon V_x\to V_y$ such
  that $(u,v)\in E_x\iff(\phi(u),\phi(v))\in E_y$, $\forall u,v\in V_x$. Since
  $\phi$ must map vertices on the ``spine'' of $G_x$ to corresponding vertices
  in $G_y$, and since $(v_i, v_{zero})\in E_x$, then $(\phi(v_i),
  \phi(v_{zero}))=(v_i, \phi(v_{zero}))$ must be in $E_y$. The only edge of
  this form in $E_y$ is $(v_i, v_{zero})$ so $\phi(v_{zero})=v_{zero}$. Since
  $(v_j, v_{zero})\in E_x$, $(\phi(v_j), \phi(v_{zero}))=(v_j, v_{zero})\in
  E_y$. But the only edge in $E_y$ with source vertex $v_j$ is, by
  construction, $(v_j, v_{one})$. This is a contradiction. Hence no such
  bijection exists, so $G_x$ is not isomorphic to $G_y$, and
  $\pair{M(x)}{M(y)}\notin DirGI$.

  Therefore $\pair{x}{y}\in R_{eqc} \iff \pair{M(x)}{M(y)}\in DirGI$, so
  $R_{eqc}\kr DirGI$.
\end{proof}

\begin{corollary}$R_{eqc}\kr GI$\end{corollary}
\begin{proof}Follows directly from \autoref{thm:reqi_kr_dirgi} and
  \autoref{lem:gi_ke_dirgi}.\end{proof}

\begin{theorem}\label{thm:ra_kr_dirgi}$\forall a\in\sigmastar$, $R_a \kr DirGI$
\end{theorem}
\begin{proof}
  Let $a\in\sigmastar$. Construct machine $M\in\FP$ on input $w\in\sigmastar$
  (let $n=|w|$):\\
  \begin{algorithm}[H]
    $U_w\gets\{v_1, v_2, \ldots, v_n\}$\;
    $U'_w\gets\{v'_1, v'_2, \ldots, v'_n\}$\;
    $F_w\gets\{(v_1, v_2), (v_2, v_3), \ldots, (v_{n-1},
    v_n)\}$\tcp*[f]{directed edges}\;
    $F'_w\gets\{(v'_1, v'_2), (v'_2, v'_3), \ldots, (v'_{n-1},
    v'_n)\}$\tcp*[f]{directed edges}\;
    \For{$i=1$ \KwTo $n$}{
      \If{$w_i=1$}{
	      add vertex $u_i$ to $U_w$\;
	      add directed edge $(v_i, u_i)$ to $F_w$\;
      }
      \If{$w_i\oplus a_i=1$}{
	      add vertex $u'_i$ to $U'_w$\;
	      add directed edge $(v'_i, u'_i)$ to $F'_w$\;
      }
    }
    $V_w\gets U_w\cup U'_w$\;
    $E_w\gets F_w\cup F'_w$\;
    \Return{$G_w=(V_w, E_w)$}
  \end{algorithm}
  Notice that for each input string $w$, this machine produces a graph which is
  the disjoint union of two distinct graphs, one representing the bits of $w$
  and the other representing the bits of $w\oplus a$.
  
  Suppose $\pair{x}{y}\in R_a$, so either $x=y$ or $x\oplus y=a$.
  
  In the case that $x=y$, $M(x)$ and $M(y)$ output exactly the same graph, so
  $G_x$ is isomorphic to $G_y$, and hence $\pair{M(x)}{M(y)}\in DirGI$.
  
  Consider the case in which $x\neq y$, but $x\oplus y=a$. Define $\phi\colon
  V_x\to V_y$ by
  \begin{displaymath}
    \phi(v)=
    \begin{cases}
      v'_i & \plain{if} v=v_i \plain{for some} i\in\{1, 2, \ldots, n\}\\
      v_i & \plain{if} v=v'_i \plain{for some} i\in\{1, 2, \ldots, n\}\\
      u'_i & \plain{if} v=u_i \plain{for some} i\in\{1, 2, \ldots, n\}\\
      u_i & \plain{if} v=u'_i \plain{for some} i\in\{1, 2, \ldots, n\}\\
    \end{cases}
  \end{displaymath}
  If no $u_i$ exists or no $u'_i$ exists for some $i\in\{1, 2, \ldots, n\}$
  then we don't define $\phi$ for those values not in the domain. $\phi$ maps
  each $v_i\in V_x$ to $v'_i\in V_y$, so $(v_i, v_{i+1})\in E_x \iff
  (\phi(v_i), \phi(v_{i+1}))=(v'_i, v'_{i+1})\in E_y, \forall i\in\{1, 2,
  \ldots, n-1\}$, and $\phi$ maps each $v'_i\in V_x$ to $v_i\in V_y$, so
  $(v'_i, v'_{i+1})\in E_x \iff (\phi(v'_i), \phi(v'_{i+1}))=(v_i, v_{i+1})\in
  E_y, \forall i\in\{1, 2, \ldots, n-1\}$.

  Now for each $i\in\{1, 2, \ldots, n\}$ for which $u_i$ exists and is in
  $V_x$, $(v_i, u_i)\in E_x$ by construction. This occurs if and only if
  $x_i=1$, and since by hypothesis $x\oplus y=a \iff y=x\oplus a$,
  $y_i=x_i\oplus a_i$. In the case that $a_i=0$, then $y_i=x_i\oplus a_i=
  1\oplus 0=1$. Since $y_i=1$ and $y_i\oplus a_i=1\oplus 0=1$, $M(y)$ produces
  graph $G_y$ containing vertex $u'_i\in V_y$ and directed edge $(v'_i,
  u'_i)\in E_y$. Now $\phi(u_i)=u'_i$ is well-defined, and $(v_i, u_i)\in
  E_x\iff (\phi(v_i), \phi(u_i))=(v'_i, u'_i)\in E_y$. In the case that
  $a_i=1$, then $y_i=x_i\oplus a_i=1\oplus1=0$. Since $y_i=0$ and $y_i\oplus
  a_i=0\oplus 1=1$, $M(y)$ produces graph $G_y$ containing vertex $u'_i\in V_y$
  and directed edge $(v'_i, u'_i)\in E_y$. Now $\phi(u_i)=u'_i$ is
  well-defined, and $(v_i, u_i)\in E_x\iff (\phi(v_i), \phi(u_i))=(v'_i,
  u'_i)\in E_y$.

  Now for each $i\in\{1, 2, \ldots, n\}$ for which $u'_i$ exists and is in
  $V_x$, $(v'_i, u'_i)\in E_x$ by construction. This occurs if and only if
  $x_i\oplus a_i=1$, and since by hypothesis $x\oplus y=a \iff y=x\oplus a$,
  then $y_i=x_i\oplus a_i=1$. Since $y_i=1$, $M(y)$ produces graph $G_y$
  containing vertex $u_i\in V_y$ and directed edge $(v_i, u_i)\in E_y$. Now
  $\phi(u'_i)=u_i$ is well-defined, and $(v'_i, u'_i)\in E_x\iff (\phi(v'_i),
  \phi(u'_i))=(v_i, u_i)\in E_y$. Therefore $\phi$ describes an isomorphism
  between graphs $G_x$ and $G_y$, so $\pair{M(x)}{M(y)}\in DirGI$.

  Suppose $\pair{x}{y}\notin R_a$, so $x\neq y$ and $x\oplus y\neq a$. Thus
  $\exists i,j\in\{1, 2, \ldots, n\}: x_i\neq y_i$ and $x_j\oplus y_j\neq a_j$
  (with the possibility that $i=j$). Because $M(x)$ and $M(y)$ both produce
  graphs which are the disjoint union of two distinct subgraphs, $(U_x, F_x)$
  and $(U'_x, F'_x)$ in $G_x$ and $(U_y, F_y)$ and $(U'_y, F'_y)$ in $G_y$, if
  the graphs $G_x$ and $G_y$ were isomorphic, the bijection between them must
  either map vertices of $U_x$ to $U_y$ and $U'_x$ to $U'_y$ or map vertices of
  $U_x$ to $U'_y$ and $U'_x$ to $U_y$. The only possible bijections must map
  either $v_i\in U_x$ to $v_i\in U_y$ and $v'_i\in U'_x$ to $v'_i\in U'_y$ or
  $v_i\in U_x$ to $v'_i\in U'_y$ and $v'_i\in U'_x$ and $v_i\in U_y$, $\forall
  i\in\{1, 2, \ldots, n\}$, because of the chain of directed edges between each
  vertex of adjacent index.

  Assume without loss of generality that $x_i=1$ and $y_i=0$, which implies
  $(v_i, u_i)\in F_x$ but $(v_i, u_i)\notin F_y$. Now $\phi$ cannot map $v_i\in
  U_x$ to $v_i\in U_y$ and $v'_i\in U'_x$ to $v'_i\in U'_y$ because $(v_i,
  u_i)\in F_x$ but $(v_i, u_i)\notin F_y$. 

  Assume $\phi$ describes a graph isomorphism which maps $v_j\in U_x$ to
  $v'_j\in U'_y$ and $v'_j\in U'_x$ to $v_j\in U_y$. In the case that $x_j=0$,
  $y_j=0$ and $a_j=1$, then $y_j\oplus a_j=1$, so $(v_j, u_j)\notin F_x$ but
  $(v'_j, u'_j)\in F'_y$. This is a contradiction with the assumption that
  $\phi$ describes a graph isomorphism. In the case that $x_j=1$, $y_j=1$ and
  $a_j=1$, then $y_j\oplus a_j=0$, so $(v_j, u_j)\in F_x$ but $(v'_j,
  u'_j)\notin F'_y$. This is a contradiction. In the case that $x_j=0$,
  $y_j=1$, and $a_j=0$, then $y_j\oplus a_j=1$, so $(v_j, u_j)\notin F_x$ but
  $(v'_j, u'_j)\in F'_y$. This is a contradiction. In the case that $x_j=1$,
  $y_j=0$, and $a_j=0$, then $y_j\oplus a_j=0$, so $(v_j, u_j)\in F_x$ but
  $(v'_j, u'_j)\notin F'_y$. This is a contradiction. Therefore no such
  bijection $\phi$ exists. Therefore $G_x$ is not isomorphic to $G_y$, thus
  $\pair{M(x)}{M(y)}\notin DirGI$.

  Therefore $\pair{x}{y}\in R_a\iff \pair{M(x)}{M(y)}\in DirGI$, so $R_a\kr
  DirGI$.
\end{proof}

\begin{corollary}$R_a\kr GI$\end{corollary}
\begin{proof}Follows directly from \autoref{thm:ra_kr_dirgi} and
  \autoref{lem:gi_ke_dirgi}.\end{proof}

\subsection{Graph isomorphism and \texorpdfstring{\NPEq}{NPEq}-completeness}

One question we wish to address is whether there exist \NPEq-complete problems
(indeed, whether there exist \PEq-complete problems as well). While we can't
yet describe what an \NPEq-complete problem looks like, we know some
\NP-complete equivalence problems. We first define a complete graph and a
clique.

\begin{definition}
  Let $K_n=(V, E)$ be an undirected graph such that $|V|=n$ and $\forall u,v\in
  V$, with $u\neq v$, $\{u,v\}\in E$. Then $K_n$ is called the \defn{complete
    graph} with $n$ vertices.
\end{definition}
\begin{definition}
  Let $G=(V,E)$ be an undirected graph. Then $C\subseteq V$ is a \defn{clique}
  if $\forall u,v\in C$, with $u\neq v$, $\{u, v\}\in E$. In other words, the
  subgraph of $G$ induced by $C$ is a complete graph.
\end{definition}

%% TODO what about letting k be fixed first, then using ((G_1, k),(G_2,k))
\begin{definition}
%  \hangindent=1.2in 
  $R_{KC}=\{\pair{\pair{G_1}{k_1}}{\pair{G_2}{k_2}}| k_1=k_2$ and $(G_1\cong
  G_2$ or $(G_1$ has a clique of size $k_1$ and $G_2$ has a clique of size
  $k_2))\}$
\end{definition}

\begin{theorem}
  $R_{KC}$ is an equivalence relation on $\sigmastar$.
\end{theorem}
\begin{proof}To show that $R_{KC}$ is an equivalence relation, we must show
  that it is reflexive, symmetric, and transitive.

  Since $G$ is isomorphic to $G$ for all graphs $G$,
  $\pair{\pair{G}{k}}{\pair{G}{k}}\in R_{KC}$, for all $k\in\mathbb{N}$, so
  $R_{KC}$ is reflexive.

  To show that $R_{KC}$ is symmetric, suppose
  $\pair{\pair{G_1}{k_1}}{\pair{G_2}{k_2}}\in R_{KC}$. In the case that $G_1$
  is isomorphic to $G_2$, then $G_2$ is isomorphic to $G_1$ because the
  isomorphism relation is symmetric, so
  $\pair{\pair{G_2}{k_2}}{\pair{G_1}{k_1}}\in R_{KC}$. In the case that $G_1$
  has a clique of size $k_1$ and $G_2$ has a clique of size $k_2$ and
  $k_1=k_2$, then $\pair{\pair{G_2}{k_2}}{\pair{G_1}{k_1}}\in R_{KC}$ because
  the logical conjunction operation is commutative over propositions.

  To show that $R_{KC}$ is transitive, suppose
  $\pair{\pair{G_1}{k_1}}{\pair{G_2}{k_2}}\in R_{KC}$ and
  $\pair{\pair{G_2}{k_2}}{\pair{G_3}{k_3}}\in R_{KC}$. Since $k_1=k_2$ and
  $k_2=k_3$, then $k_1=k_3$ by the transitivity of the equality relation. There
  are four possible cases for the remaining properties.

  In the case that $G_1$ is isomorphic to $G_2$ and $G_2$ is isomorphic to
  $G_3$, then $G_1$ is isomorphic to $G_3$ so
  $\pair{\pair{G_1}{k_1}}{\pair{G_3}{k_3}}\in R_{KC}$.

  In the case that $G_1$ is isomorphic to $G_2$, $G_2$ has a clique of size
  $k_2$, $G_3$ has a clique of size $k_3$, then $G_1$ has a clique of size
  $k_2=k_1$, so $\pair{\pair{G_1}{k_1}}{\pair{G_3}{k_3}}\in R_{KC}$.

  In the case that $G_1$ has a clique of size $k_1$, $G_2$ has a clique of size
  $k_2$, and $G_2$ is isomorphic to $G_3$, then $G_3$ has a clique
  of size $k_2=k_3$, so $\pair{\pair{G_1}{k_1}}{\pair{G_3}{k_3}}\in R_{KC}$.

  In the case that $G_1$ has a clique of size $k_1$, $G_2$ has a clique of size
  $k_2$, and $G_3$ has a clique of size $k_3$, then
  $\pair{\pair{G_1}{k_1}}{\pair{G_3}{k_3}}\in R_{KC}$.

  Therefore $R_{KC}$ is reflexive, symmetric, and transitive, hence it is an
  equivalence relation.
\end{proof}

\begin{definition}
  $CLIQUE=\{\pair{G}{k}|G$ has a clique of size $k\}$
\end{definition}

\begin{lemma}$CLIQUE$ is \NP-complete.\end{lemma}
\begin{proof}
  The proof is omitted; we refer the reader to \cite{gj79} for the reduction.
\end{proof}

%% TODO rewrite algorithms using \KwIn and \KwOut
\begin{lemma}\label{lem:rkc_np}$R_{KC}\in\NP$\end{lemma}
\begin{proof}
  Since $GI\in\NP$, it has a deterministic polynomial time verifier, $M_1$,
  which accepts on input $\triple{G_1}{G_2}{c}$, where $c$ is the isomorphism
  from vertices of $G_1$ to vertices of $G_2$.

  Since $CLIQUE\in\NP$, it has a deterministic polynomial time verifier, $M_2$,
  which accepts on input $\triple{G}{k}{c}$, where $c$ is the set of vertices
  in $G$ which comprise a clique of size $k$.

  To show that $R_{KC}\in\NP$, we construct a deterministic polynomial time
  verifier $M$ for $R_{KC}$. On input
  $\triple{\pair{G_1}{k_1}}{\pair{G_2}{k_2}}{c}$:\\
  \begin{algorithm}[H]
    If $k_1\neq k_2$, \REJECT\;
    \If{$c$ \textnormal{is the encoding of a mapping}}{
      Run $M_1$ on input $\triple{G_1}{G_2}{c}$\;
      If $M_1$ accepts, \ACCEPT; otherwise \REJECT\;
    }
    \If{$c=\pair{c_1}{c_2}$ \textnormal{is the encoding of two cliques}}{
      Run $M_2$ on input $\triple{G_1}{k_1}{c_1}$\;
      Run $M_2$ on input $\triple{G_2}{k_2}{c_2}$\;
      If $M_2$ accepts on both inputs, \ACCEPT; otherwise \REJECT\;
    }
  \end{algorithm}
  
  Machine $M$ is a verifier for $R_{KC}$, so $R_{KC}\in\NP$.
\end{proof}

\begin{corollary}\label{cor:rkc_npeq}$R_{KC}\in\NPEq$\end{corollary}
\begin{proof}
  Since $R_{KC}\in\NP$ by \autoref{lem:rkc_np} and $R_{KC}$ is an equivalence
  problem, then by \autoref{def:peq}, $R_{KC}\in\NPEq$.
\end{proof}

\begin{theorem}\label{thm:rkc_npc}$R_{KC}$ is \NP-complete.\end{theorem}
\begin{proof}
  Since $R_{KC}\in\NP$ by \autoref{lem:rkc_np}, we need only show that $R_{KC}$
  is \NP-hard. To do this, we construct a polynomial time many-one reduction
  from $CLIQUE$, which is \NP-complete, to $R_{KC}$.

  Construct machine $M\in\FP$ on input $\pair{G}{k}$ which outputs
  $\pair{\pair{G}{k}}{\pair{K_k}{k}}$, where $K_k$ is the complete graph with
  $k$ vertices.

  Suppose $\pair{G}{k}\in CLIQUE$, so $G$ has a clique of size $k$. Then
  $M(\pair{G}{k})=\pair{\pair{G}{k}}{\pair{K_k}{k}}\in R_{KC}$, because $G$ has
  a clique of size $k$ by hypothesis and $K_k$ has a clique of size $k$ by
  construction, specifically, the set of all vertices in $K_k$.
  
  Suppose $\pair{G}{k}\notin CLIQUE$, so $G$ does not have a clique of size $k$
  and $M(\pair{G}{k})=\pair{\pair{G}{k}}{\pair{K_k}{k}}$. If $G$ were
  isomorphic to $K_k$, then it would have a clique of size $k$, specifically
  the set of all its vertices, but this is a contradiction with the hypothesis
  so no such isomorphism exists. Although $K_k$ certainly has a clique of size
  $k$, specifically the set of all its vertices, $G$ does not have a clique of
  size $k$ by hypothesis, so $\pair{\pair{G}{k}}{\pair{K_k}{k}}\notin R_{KC}$.
  
  Therefore $\pair{G}{k}\in CLIQUE\iff M(\pair{G}{k})\in R_{KC}$, so $CLIQUE\mor R_{KC}$,
  and hence $R_{KC}$ is \NP-complete.
\end{proof}

So we have now shown that $R_{KC}\in\NPC\cap\NPEq$, where $\NPC$ is the set of
all \NP-complete languages. With this fact we can show a relationship between
completeness under kernel reductions and completeness under many-one reductions
in $\NPEq$ which follows from the fact that a kernel reduction implies a
many-one reduction.

\begin{theorem}\label{thm:npeqc_npc}If an equivalence relation $A$ is
  \NPEq-complete, then $A$ is \NP-complete.\end{theorem}
\begin{proof}
  If $A$ is \NPEq-complete then $R_{KC}\kr A$, since $R_{KC}\in\NPEq$ by
  \autoref{cor:rkc_npeq}. By \autoref{lem:kr_mor}, $R_{KC}\kr A\implies
  R_{KC}\mor A$. Since $R_{KC}$ is \NP-complete by \autoref{thm:rkc_npc}, then
  $A$ is \NP-complete.
\end{proof}

Of course, \autoref{thm:npeqc_npc} is not all that useful if \NPEq-complete
problems do not exist. We wish to give some evidence that $R_{KC}$ (or a
language similar to it) may be \NPEq-complete. We know that many problems in
\NP, specifically many in \NPEq, kernel reduce to the graph isomorphism problem
(in the past, the reductions have not explicitly been presented as kernel
reductions, but we can retroactively identify the techniques used as such). If
we can show a polynomial time kernel reduction from the graph isomorphism
problem to $R_{KC}$, then we have found many $\NPEq$ problems which reduce to
$R_{KC}$. Indeed, we defined $R_{KC}$ in such a way to allow a kernel reduction
from the graph isomorphism problem to be possible.

\begin{theorem}$GI\kr R_{KC}$\end{theorem}
\begin{proof}
  Construct machine $f\in\FP$ defined for all graphs $G=(V,E)$ by
  $f(G)=\pair{G}{|V|+1}$.

  Let $G_1=(V_1, E_1)$ and $G_2=(V_2, E_2)$, and suppose $\pair{G_1}{G_2}\in
  GI$, so $G_1$ is isomorphic to $G_2$. This implies $|V_1|=|V_2|$ and thus
  $|V_1|+1=|V_2|+1$. Now $f(G_1)=\pair{G_1}{|V_1|+1}$ and $f(G_2)=\pair{G_2}{
  |V_2|+1}$. Since $G_1$ is isomorphic to $G_2$ and $|V_1|+1=|V_2|+1$, then
  $\pair{\pair{G_1}{|V_1|+1}}{\pair{G_2}{|V_2|+1}}=\pair{f(G_1)}{f(G_2)}\in
  R_{KC}$.
  
  Suppose $\pair{G_1}{G_2}\notin GI$, so $G_1$ is not isomorphic to $G_2$. Even
  in the case that $|V_1|=|V_2|$, $G_1$ cannot have a clique of size $|V_1|+1$,
  and $G_2$ cannot have a clique of size $|V_2|+1$. Thus
  $\pair{\pair{G_1}{|V_1|+1}}{\pair{G_2}{|V_2|+1}}=\pair{f(G_1)}{f(G_2)}\notin
  R_{KC}$.

  Therefore $\pair{G_1}{G_2}\in GI\iff \pair{f(G_1)}{f(G_2)}\in R_{KC}$, so
  $GI\kr R_{KC}$.
\end{proof}

We constructed $R_{KC}$ in order to make this reduction easy, but there is in
fact another known problem in $\NPEq\cap\NPC$. Garey and Johnson provide a
single \NP-complete equivalence problem: a databases problem concerning the
equivalence of tableaux.\cite{gj79} The original proof is a reduction from
\TSAT.\cite{asu79}

Reductions between the graph isomorphism problem and other equivalence problems
in $\NPEq$ abound, and though they have traditionally been presented as
many-one reductions, they are in fact kernel reductions. Zemlyachenko,
Korneenko and Tyshkevich notice this in \cite{zkt85}, and describe the kernel
reductions in the terminology of category theory as follows: Let $C_1$ and
$C_2$ be concrete categories, let $x,y$ be objects in $C_1$, let $x', y'$ be
objects in $C_2$, let $Mor_{C_1}(x,y)$ be the morphism between objects $x$ and
$y$ in $C_1$, let $Mor_{C_2}(x',y')$ be the morphism between objects $x'$ and
$y'$ in $C_2$, and let $f\colon C_1\to C_2$ be a functor. Define $g\colon
Mor(C_1)\to Mor(C_2)$ by $g(Mor_{C_1}(x,y))=Mor_{C_2}(f(x), f(y))$. If $g$ is
bijective then $g$ is called a \defn{complete embedding}. If $g$ is a complete
embedding then we say the isomorphism problem for objects in category $C_1$
\defn{reduces functorially} to the isomorphism problem for objects in category
$C_2$.
%% TODO grigor'ev83 describes a kernel reduction as an epimorphic functor

Notice that in the above definition, if we let $R=\{\pair{x}{y}| x$ and $y$ are
objects of $C_1$ and $x$ is isomorphic to $y$ by $Mor_{C_1}(x,y)\}$ and
$S=\{\pair{x}{y}| x$ and $y$ are objects of $C_2$ and $x$ is isomorphic to $y$
by $Mor_{C_2}(x,y)\}$, then $R\kr S$ by $f$, and $R\mor S$ by $g$, the many-one
reduction induced by the kernel reduction $f$.

A functorial reduction as defined above is \emph{more restrictive} than a
kernel reduction, because it requires that there exist a bijection between the
isomorphisms of the two categories. The definition of a kernel reduction does
not demand this bijection, so a functorial reduction implies a kernel
reduction.

In \cite{zkt85}, the authors provide a survey of categories for which
isomorphism problems are polynomial-time functorially equivalent. For our
purposes, this is a simply a listing of equivalence problems which are
polynomial time kernel equivalent to graph isomorphism. We have, in addition,
provided some more recent results on isomorphism of objects in other
categories.

\begin{itemize}
\item directed graph isomorphism \cite{miller79}
\item labeled tree isomorphism \cite{babai79}
\item polar graph isomorphism \cite{zkt85}
\item two-color graph isomorphism \cite{zkt85}
\item finite model isomorphism \cite{miller79} %\cite{babai77}
\item color graph isomorphism \cite{zkt85, miller77, pultr64}
\item stable graph isomorphism \cite{wl68}
\item multigraph isomorphism \cite{zkt85} 
\item hypergraph isomorphism \cite{zkt85} 
\item $k$-uniform hypergraph isomorphism \cite{zkt85, hn70}
\item finite automaton isomorphism \cite{booth78}
\item lattice isomorphism \cite{frucht50}
\item isomorphism of commutative nilpotent semigroups of class 3 
  % [32] L. Babai, ``On the isomorphism problem.''  App. to
  % Proc. Conf. Foundat. Comput. Theory, Poland (1977), pp. 19-23.
\item isomorphism of associative algebras of finite rank over a fixed
  algebraically closed field with a square of the radical equal to zero and
  with a commutative factor with respect to the radical \cite{grigoriev83}
\item Markov decision process isomorphism \cite{nr08}
\item context-free grammar isomorphism
  % [76] H. B. Hunt, III and D. J. Rosenkrantz, ``Complexity of grammatical
  % similarity relations,'' Proc. Conf. Theor. Comput. Sci.,
  % Comput. Sci. Dept., Univ. Waterloo, Ontario (1978), pp. 139-145.
\item balanced incomplete block-scheme isomorphism \cite{cc81}
\item combinatorial isomorphism of convex polytopes represented by
  vertex-facet incidences \cite{ks03}
\item equivalence of Hadamard matrices \cite{mckay79}
% \item etc. [17] A. I. Kostyukovich,''Polynomial equivalence of certain
% discrete optimization problems,'' Izv. Akad. Nauk BSSR, Ser. Fiz.-Mat. Nauk,
% No. 4, 47-49 (1979).
\end{itemize}
%% TODO ``Babai noted that a functorial reduction of graph isomorphism to
%% isomorphism of Dedekind lattices does not exist [32]''.

We will consider the general class of problems equivalent to the graph
isomorphism problem under polynomial time kernel reductions by defining the
following complexity class.

\begin{definition}
  $\GIk=\{A|A\kequiv GI\}$
\end{definition}

All of the problems cited above fall in this class.

\begin{lemma}\label{lem:gik_npeq}
  $\GIk\subset\NPEq$
\end{lemma}
\begin{proof}
  Let $A\in\GIk$. Then $A\kr GI$ and hence $A\mor GI$. Since $GI\in\NP$ and
  $\NP$ is closed under polynomial time many-one reductions, $A\in\NP$. Since
  $A$ is an equivalence problem by definition (only equivalence problems can
  kernel reduce), then $A\in\NPEq$. Therefore $\GIk\subseteq\NPEq$.
\end{proof}

There is evidence that shows that the graph isomorphism problem is not
\NP-complete, specifically that it is not \NP-complete unless the polynomial
time hierarchy collapses to the second level\cite{schoning87}. If this is true,
then the following theorem about the complexity of all equivalence problems
equivalent under polynomial time kernel reductions to the graph isomorphism
problems follows.

\begin{theorem}
  If $GI$ is not $\mor$-complete in $\NP$, then $\GIk\subsetneq\NPEq$.
\end{theorem}
\begin{proof}
  By \autoref{lem:gik_npeq}, $\GIk\subset\NPEq$.

  Assume with the intention of producing a contradiction that
  $\GIk=\NPEq$. Since every language $A$ in $\GIk$ polynomial time kernel
  reduces to $GI$, $GI$ is complete under polynomial time kernel reductions in
  $\GIk$. Since $\GIk=\NPEq$, $GI$ is complete under polynomial time kernel
  reductions in $\NPEq$. By \autoref{thm:npeqc_npc}, $GI$ is $\mor$-complete in
  $\NP$. This is a contradiction with the hypothesis that $GI$ is not
  $\mor$-complete.
\end{proof}
Intuitively, this means that if the graph isomorphism problem is not
\NP-complete, then there are equivalence problems harder than the graph
isomorphism problem in $\NP$, unless $\P=\NP$.

The graph isomorphism problem has been (and continues to be) extensively
studied. For more information, see \cite{kst93}.

%% TODO study hard equivalence problems: Boolean formula isomorphism? algebraic
%% structure equivalence relations (bloniarz84)? regular expressions with + and
%% times?  see Boolean equivalence problems paper

\section{Kernel reductions vs. many-one reductions}

Now we wish to address the question of whether kernel reductions are different
from many-one reductions.

To show that they are in fact different, we need only exhibit two equivalence
relations, $R$ and $S$, such that $R\mor S$ but $R\nkr S$. Intuitively, this
means that when $\pair{x}{y}\in R$, there is some information shared between
$x$ and $y$ which can not be separated from either. In other words, $x$ can
only be understood with knowledge of $y$ and $y$ can only be understood with
knowledge of $x$. In attempting to construct such a relation, we have found
that reflexivity, symmetry, and transitivity of a relation seem to provide a
significant obstacle to the possibility of sharing information between related
elements.

To show that the two reductions are the same, we need to prove that a many-one
reduction implies a kernel reduction. Proving this seems even more difficult
than proving the negation. A many-one reduction gets access to both related
elements, and using a many-one reduction to construct a kernel reduction would
require something like examining the machine which computes the many-one
reduction and determining in which states that machine is ``using'' which of
the elements.

Still, we have no reason in particular to believe that a many-one reduction is
different from a kernel reduction.
%% TODO more explanation

\bibliographystyle{amsalpha} \bibliography{references}

\end{document}
